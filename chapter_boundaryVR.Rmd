---
title: 'Chapter: boundaryVR'
author: "Joern Alexander Quent"
output: 
  word_document:
    toc: true
    toc_depth: 4
always_allow_html: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE)

# Libraries
library(plyr)
library(ggplot2)
library(cowplot)
library(gridExtra)
library(grid)
library(knitr)
library(assortedRFunctions)
library(kableExtra)
library(MRColour)
library(jsonlite)
library(reshape2)
library(latex2exp)
library(lmerTest)
library(ez)
library(BayesFactor)
theme_set(theme_grey()) 
```

```{r table_from_Horner2016}
# Aidan's results
# Which object came next?
aidansData1 <- data.frame(Experiment = c('Exp 1', 'Exp 1', 'Exp 2', 'Exp 2', 'Exp 3', 'Exp 3'),
                         Context = c('within', 'across', 'within', 'across', 'within', 'across'),
                         accuracy = c(0.52, 0.42, 0.45, 0.38, 0.52, 0.44),
                         SD = c(0.15, 0.1, 0.17, 0.18, 0.18, 0.14))

v1 <- aidansData1$accuracy[aidansData1$Context == 'within'] - aidansData1$accuracy[aidansData1$Context == 'across']

# Which object came before?
aidansData2 <- data.frame(Experiment = c('Exp 1', 'Exp 1', 'Exp 2', 'Exp 2', 'Exp 3', 'Exp 3'),
                         Context = c('within', 'across', 'within', 'across', 'within', 'across'),
                         accuracy = c(0.42, 0.38, 0.46, 0.41, 0.49, 0.44),
                         SD = c(0.15, 0.13, 0.21, 0.16, 0.18, 0.17))

v2 <- aidansData2$accuracy[aidansData2$Context == 'within'] - aidansData2$accuracy[aidansData2$Context == 'across']
```

# Introduction
As we experience the world through a continuous stream of sensory input, our brains are constantly trying to predict what comes next. Prediction errors (PE) can result in “event boundaries”, which segment our memories for our experiences (add quotes). Walking into a new room is thought to trigger such a boundary, as evidenced by better temporal order memory for objects within the same room than for objects in different rooms, e.g. in a virtual environment (Horner et al., 2016). However, walking between rooms also typically results in large perceptual changes (PC). Here I report an experiment that was designed to tease apart the contributions of PE and PC to the formation of event boundaries.

I designed an “M-room” for virtual environments (add FIGURE). When traversing such a room, the viewer can only see one half of the room until they reach the middle section. This enables independent manipulation of PE and PC: PC can be induced by changing the wall colours between the two halves of the room, and PE can be induced by presenting a cue indicating the colour of the second half, which is then violated.
 
The first step in this study was a pilot study to verify that crossing to the second half of the room in the M-room in the absence of PC or PE does not constitute a boundary. To test this, we examined whether the superior temporal order memory for objects within the same room is similar in M-rooms and the “O-rooms”  used in Horner et al. (2016). For that, participants encountered 88 objects in a series of virtual rooms. 

In three experiments, I describe how I failed to replicate the boundary effect on memory (i.e. within > across) while successively removing possible confounds. 

# Experiment 1
## Method
### Participant pool
In all experiments, we recruited participants from the website https://www.prolific.co/. 

<!-- Add demographics etc. -->
### Procedure
Participants first saw a video of another camera navigating through a series of rooms. Note that Horner et al. (2016), participants navigated through the virtual environment themselves. After watching the video, participants completed a memory task (see below for details).

### Virtual environment and stimuli
The rooms were build with SketchUp (https://www.sketchup.com) and then imported into unity3d (https://unity.com/). 88  everyday objects were downloaded (e.g. guitar, toys, household items etc.) from archive3d (https://archive3d.net/) and edited them either in blender (https://www.blender.org/) or in unity3d itself. I tried to find as many 3D versions of objects as possible that were also used in Horner et al. (2016). The object sizes were kept to be scaled realistically to the other feature of the environment. 

In contrast to Horner et al., the layouts of all rooms of the same type were always identical including the positions of the tables differing only in wall colour and floor material (wood or carpet textures). 

In Experiment 1, M-room and O-room alternated so that each participant saw the both types of rooms. Four videos were created where the order of the objects presented was always the same (i.e. the pencils were always presented as the first object).

Video 1 and 2 two objects were presented in the first room. The first object-object sequence was hence within-boundaries. Video 3 and 4 showed only one object in the first room. The next object was therefore presented across a spatial boundary (i.e. door). The first room in video 1 and 3 was M-shaped, while the first room in video 2 and 4 was an open plane room. The reason for this was to create four counter-balancing conditions that control for the sequences of the boundary conditions (within vs. across) and which room began the series. 

Like the order of the objects, the wall colours and floor materials of the rooms were constant across the videos. The only exception to this rule was that video 3 and 4 featured 45 rooms to presented all objects. The number of wall colours (blue, brown, green, grey, orange, pink, purple, red, turquoise and yellow) and floor materials (5 different carpets and 5 different wood floors) allowed us to construct 45 unique rooms. 

Both types of rooms contained three tables, however only two were used in the experiments discussed here. The first table in the room as added for future version of the experiment that I never ran. All of tables had a cardboard box placed on top of it. If the camera approached two of the tables (see labels 1 and 2 in figure above), the cardboard boxes disappeared.

While watching the video, participants in this tasks were required to judge whether an object was smaller or bigger than a reference as soon as the object appeared. In this and all subsequent versions of the Experiment the object was visible for 3 seconds. After the 3 seconds, the object disappeared and the cardboard box that was covering the object re-appeared. This controlled the time during which the object could be seen by the participant. 

### Batch 1
#### Description of memory task
To asses the boundary effect, I showed participants a cue object with three images under it one of which was the target object and the other two were foils. The question the participants had to answer was "What came before this object?".

The foils were +/- 4 positions away from the target object (see Figure). This was done to implement tighter control of the foils than it was done in Horner et al. (2016). This ensured that the two foils were always from the same room type and on the same table as the target. 

An in-lab pilot experiment has shown that participants could not identify the exact room a particular objects was in based on as still image that showed wall colour and floor texture. This memory question was therefore not used again. However, I asked participants to choose the but room type and table type in a 2AFC task.  

#### Sample
```{r exp1_batch1_demographics}
# Load data
exp1a_demographics <- read.table("~/boundaryVR/data/Exp1/batch1/exp1a_demographics.csv", header = TRUE, sep = ',')

# Exclude returned (not approved)
exp1a_demographics <- exp1a_demographics[exp1a_demographics$status != 'RETURNED', ]

# Exclude no codes 
exp1a_demographics <- exp1a_demographics[exp1a_demographics$entered_code != 'NOCODE', ]

# Create strings
str1      <- mean_SD_str2(exp1a_demographics$age, 1)
sex_table <- table(droplevels.factor(exp1a_demographics$Sex)) 
```

In total, 10 participants (`r sex_table[1]`  female and `r sex_table[2]` male)  recruited through prolific completed this version of the experiment. Their age was `r str1` years. 

#### Statistical analysis
<!-- add description -->

#### Results
```{r exp1_batch1_loadData}
# Load all data
prefix         <- "~/boundaryVR/data/Exp1/batch1/memoryTask/"
allFiles       <- list.files(paste(prefix, sep = ''))
allFiles_paths <- paste(prefix, allFiles, sep = '')
n              <- length(allFiles_paths)

for(i in 1:n){
  ############
  # Load data files
  tempDF <- read.csv(allFiles_paths[i], header = TRUE, na.strings = '')
  
  # Recode key presses
  response      <- rep(NA, dim(tempDF)[1])
  response[tempDF$key_press == 49] <- 1
  response[tempDF$key_press == 50] <- 2
  response[tempDF$key_press == 51] <- 3
  tempDF$response <- response
  
  ############
  # Temporal order
  temporalOrder    <- subset(tempDF, test_part == 'temporalOrder')
  temporalOrder$rt <- as.numeric(as.character(temporalOrder$rt))
  
  # Calculate accuracy
  accuracy <- rep(NA, dim(temporalOrder)[1])
  accuracy[temporalOrder$response == temporalOrder$corr_resp] <- 1
  accuracy[temporalOrder$response != temporalOrder$corr_resp] <- 0
  temporalOrder$accuracy <- accuracy

  ############
  # Room type question
  roomType      <- subset(tempDF, test_part == 'roomType')
  roomType$rt   <- as.numeric(as.character(roomType$rt))
  
  # Calculate accuracy
  accuracy <- rep(NA, dim(roomType)[1])
  accuracy[roomType$response == roomType$corr_resp] <- 1
  accuracy[roomType$response != roomType$corr_resp] <- 0
  roomType$accuracy <- accuracy
  
  ############
  # Table question
  tableNum      <- subset(tempDF, test_part == 'tableNum')
  tableNum$rt   <- as.numeric(as.character(tableNum$rt))
  
  # Recode because tables are named 2 and 3 in input data
  tableNum$response[tableNum$key_press == 49] <- 3 # for key press 1
  tableNum$response[tableNum$key_press == 50] <- 2 # for key press 2
  
  # Calculate accuracy
  accuracy <- rep(NA, dim(tableNum)[1])
  accuracy[tableNum$response == tableNum$corr_resp] <- 1
  accuracy[tableNum$response != tableNum$corr_resp] <- 0
  tableNum$accuracy <- accuracy
  
  # Add subject ID and concatenate to 1 data.frame
  if(i == 1){
    df_order    <- temporalOrder
    df_order$id <- i
    df_room     <- roomType
    df_room$id  <- i
    df_table    <- tableNum
    df_table$id <- i
  } else {
    temporalOrder$id <- i
    df_order         <- rbind(df_order, temporalOrder)
    roomType$id      <- i
    df_room          <- rbind(df_room, roomType)
    tableNum$id      <- i
    df_table         <- rbind(df_table, tableNum)
  }
}

# Rename according for batch1
df_order_b1 <- df_order 
df_room_b1  <- df_room
df_table_b1 <- df_table

# Convert ID to factor
df_order_b1$id <- as.factor(df_order_b1$id)
df_room_b1$id  <- as.factor(df_room_b1$id)
df_table_b1$id <- as.factor(df_table_b1$id)

# Recode factor levels
levels(df_order_b1$context) <- c('across', 'within-open plane', 'within-M-shape')

# Calculate mean accuracy
agg_order_b1 <- ddply(df_order_b1, c('id', 'context'), summarise, acc = mean(accuracy), rt = mean(rt))
agg_room_b1  <- ddply(df_room_b1, c('id'), summarise, acc = mean(accuracy))
agg_table_b1 <- ddply(df_table_b1, c('id'), summarise, acc = mean(accuracy))

# Do arcsine transformation
agg_order_b1$trans_acc <- arcsine_transform(agg_order_b1$acc)
agg_room_b1$trans_acc  <- arcsine_transform(agg_room_b1$acc)
agg_table_b1$trans_acc <- arcsine_transform(agg_table_b1$acc)

# Rename factor
agg_order_b1$boundary <- ifelse(agg_order_b1$context == 'across', 'across', 'within')
agg_order_b1$Condition <- 'across'
agg_order_b1$Condition[agg_order_b1$context == 'within-open plane'] <- 'O-room'
agg_order_b1$Condition[agg_order_b1$context == 'within-M-shape']    <- 'M-room'

# Get trial number etc. 
exp1a_trials     <- ddply(df_order_b1, c('id','condition', 'context'), summarise, n = length(id))
exp1a_trials_agg <- ddply(exp1a_trials, c('condition', 'context'), summarise, n = mean(n))
```

```{r exp1_batch1_plot1}
# /* 
# ----------------------------- Exp 1 Batch 1: Plots ---------------------------
# */
plt1 <- ggplot(agg_order_b1, aes(x = boundary, y = acc, group = Condition, colour = Condition)) + 
  geom_boxplot(alpha = 0.5,outlier.shape = NA, key_glyph = "rect") + 
  geom_point(position = position_jitterdodge(jitter.width = 0.2)) + 
  geom_hline(yintercept = 1/3) +
  stat_summary(geom = "point", fun = "mean", col = 'black', size = 3, shape = 24, aes(fill = Condition),
               position=position_dodge(width =  0.75),
               key_glyph = "rect") + 
  geom_segment(aes(x = 1.5, xend = 1.5, y= 0.1, yend= 1/3),colour = 'black',
               arrow = arrow(length = unit(0.30,"cm"), type = "closed"), show.legend = FALSE) +
  annotate('text', x = 1.5, y = 0.1 - 0.03, label = 'Chance') +
  scale_color_mrc(palette = 'secondary') + 
  scale_fill_mrc(palette = 'secondary') +
  labs(y = '3AFC accuracy', x = "Boundary", title = 'Temporal Order') + 
  theme(legend.justification = c(0, 1), 
        legend.position = c(0, 1),
        legend.title = element_text(size = 10),
        legend.text = element_text(size = 9),
        legend.key.size = unit(0.5,"line"))

# Bind room and table together
roomTable_b1 <- data.frame(id = rep(1:n, 2),
                           Type = rep(c('Room', 'Table'), each = n),
                           acc = c(agg_room_b1$acc, agg_table_b1$acc),
                           trans_acc = c(agg_room_b1$trans_acc, agg_table_b1$trans_acc))

plt2 <- ggplot(roomTable_b1, aes(x = Type, y = acc)) + 
  geom_boxplot(alpha = 0.5,outlier.shape = NA) + 
  geom_jitter(width = 0.1, height = 0) +
  geom_hline(yintercept = 0.5) +
  stat_summary(geom = "point", fun = "mean", col = 'black', size = 3, shape = 24, fill = 'red') +
  geom_segment(aes(x = 1.5, xend = 1.5, y= 0.3, yend= 0.5),colour = 'black',
               arrow = arrow(length = unit(0.30,"cm"), type = "closed"), show.legend = FALSE) +
  annotate('text', x = 1.5, y = 0.3 - 0.03, label = 'Chance') +
  labs(y = '2AFC accuracy', x = "Memory type", title = 'Room type and table')

# Combine 2 1 figure
plot_grid(plt1, plt2)
```


```{r exp1_batch1_test1}
# Temporal order question
# Overall memory performance
agg_order_overall_b1           <- ddply(df_order_b1, c('id'), summarise, acc = mean(accuracy), rt = mean(rt))
agg_order_overall_b1$trans_acc <- arcsine_transform(agg_order_overall_b1$acc)

test1 <- ttestBF(agg_order_overall_b1$trans_acc - arcsine_transform(1/3), nullInterval = c(-Inf, 0))
test1 <- reportBF(1/test1[2])

# Examine the boundary effect
## Memory
### Across versus M-room
val1  <- agg_order_b1[agg_order_b1$Condition == 'across', 'trans_acc']
val2  <- agg_order_b1[agg_order_b1$boundary  == 'within' & agg_order_b1$Condition  == 'M-room', 'trans_acc']
test2 <- ttestBF(val1, val2, paired = TRUE, nullInterval = c(-Inf, 0))
test2 <- reportBF(1/test2[1])

### Across versus O-room
val1  <- agg_order_b1[agg_order_b1$Condition == 'across', 'trans_acc']
val2  <- agg_order_b1[agg_order_b1$boundary  == 'within' & agg_order_b1$Condition  == 'O-room', 'trans_acc']
test3 <- ttestBF(val1, val2, paired = TRUE, nullInterval = c(-Inf, 0))
test3 <- reportBF(1/test3[1])

## RT
### Across versus M-room
val1  <- agg_order_b1[agg_order_b1$Condition == 'across', 'rt']
val2  <- agg_order_b1[agg_order_b1$boundary  == 'within' & agg_order_b1$Condition  == 'M-room', 'rt']
test4 <- ttestBF(val1, val2, paired = TRUE, nullInterval = c(-Inf, 0))
test4 <- reportBF(1/test4[2])

### Across versus O-room
val1  <- agg_order_b1[agg_order_b1$Condition == 'across', 'rt']
val2  <- agg_order_b1[agg_order_b1$boundary  == 'within' & agg_order_b1$Condition  == 'O-room', 'rt']
test5 <- ttestBF(val1, val2, paired = TRUE, nullInterval = c(-Inf, 0))
test5 <- reportBF(1/test5[2])

# Room question
test6 <- ttestBF(agg_room_b1$trans_acc - arcsine_transform(0.5), nullInterval = c(-Inf, 0))
test6 <- reportBF(1/test6[2])

# Table question
test7 <- ttestBF(agg_table_b1$trans_acc - arcsine_transform(0.5), nullInterval = c(-Inf, 0))
test7 <- reportBF(test7[2])
```

There was considerable evidence that memory performance was not above chance ($BF_{01}$ = `r test1`) for the temporal memory question. Furthermore, I did not find a boundary effect for M-rooms (across vs. within) for accuracy, $BF_{01}$ = `r test2`, and for RT, $BF_{01}$ = `r test4`, but I did not find an effect for O-rooms for accuracy, $BF_{01}$ = `r test3`, and for RT, $BF_{01}$ = `r test5`. 

Participants also did not show above chance performance for remembering in which room type a cue object was presented in ($BF_{01}$ = `r test6`). However, there was weak evidence that participants did remember on which table type a cue object was presented ($BF_{10}$ = `r test7`).

#### Discussion
In contrast to my expectations, I did not find boundary effect for either room type. After consultation in a lab meeting, I considered whether the question "What came before this object?" could be interpreted in a way that participants thought that both objects that appeared before the cue object (i.e. the target as well as one of the foils) would be a valid answer. 

Another notable concern was that memory performance was not above chance, which might have been another reason why I did not fnd the boundary effect. 

### Batch 2
#### Description of memory task
In order to avoid confusion I improved the instructions and the specific wording of the temporal order question. Participants were now asked "In the video you just watched, which one of the three objects at the bottom of the screen appeared immediately before this object?" in order to make sure that there is no misunderstanding. Besides other small changes to the instruction of this task, no significant changes were made. 

#### Sample
```{r exp1_batch2_demographics}
# Load data
exp1b_demographics <- read.table("~/boundaryVR/data/Exp1/batch2/exp1b_demographics.csv", header = TRUE, sep = ',')

# Exclude returned (not approved)
exp1b_demographics <- exp1b_demographics[exp1b_demographics$status != 'RETURNED', ]

# Exclude no codes 
exp1b_demographics <- exp1b_demographics[exp1b_demographics$entered_code != 'NOCODE', ]

# Create strings
str1      <- mean_SD_str2(exp1b_demographics$age, 1)
sex_table <- table(droplevels.factor(exp1b_demographics$Sex)) 
```

In total, 12 participants (`r sex_table[1]`  female and `r sex_table[2]` male)  recruited through prolific completed this version of the experiment. Their age was `r str1` years. 

#### Results
```{r exp1_batch2_loadData}
# Load trial information
load("~/boundaryVR/experiments/Exp1/batch2/r_supportFiles/trialData_20200522_182214.RData")
# Note that counterbalancing in that images goes from 1 to 8, while it goes from 0 to 7 in the javascript
# files.

# Order trial information
trials_cond5 <- trials_cond5[order(trials_cond5$objNum),]
trials_cond6 <- trials_cond6[order(trials_cond6$objNum),]
trials_cond7 <- trials_cond7[order(trials_cond7$objNum),]
trials_cond8 <- trials_cond8[order(trials_cond8$objNum),]

# Load all data
prefix         <- '~/boundaryVR/data/Exp1/batch2/memoryTask/'
allFiles       <- list.files(paste(prefix, sep = ''))
allFiles_paths <- paste(prefix, allFiles, sep = '')
n              <- length(allFiles_paths)

for(i in 1:n){
  ############
  # Loading daya
  tempDF <- read.csv(allFiles_paths[i], header = TRUE, na.strings = '')
  
  # Recode key presses
  response      <- rep(NA, dim(tempDF)[1])
  response[tempDF$key_press == 49] <- 1
  response[tempDF$key_press == 50] <- 2
  response[tempDF$key_press == 51] <- 3
  tempDF$response                  <- response
  
  ############
  # Temporal order memory
  temporalOrder <- subset(tempDF, test_part == 'temporalOrder')
  
  # Sort by objectNumber
  temporalOrder <- temporalOrder[order(temporalOrder$probe),]
  
  # get trialinfo and add to temporalOrder
  cond <- temporalOrder$condition[1] + 1 # to correct for difference
  temporalOrder$foil1Pos <- get(paste0("trials_cond", cond))$foil1Pos
  temporalOrder$foil2Pos <- get(paste0("trials_cond", cond))$foil2Pos
  
  temporalOrder$rt <- as.numeric(as.character(temporalOrder$rt))

  # Calcalate accuracy 
  accuracy <- rep(NA, dim(temporalOrder)[1])
  accuracy[temporalOrder$response == temporalOrder$corr_resp] <- 1
  accuracy[temporalOrder$response != temporalOrder$corr_resp] <- 0
  temporalOrder$accuracy <- accuracy
  
  # Create variable that desribe whether target, foil1, foil2 was choosen
  choice <- rep('Target', dim(temporalOrder)[1])
  choice[temporalOrder$response == temporalOrder$foil1Pos] <- 'Foil 1'
  choice[temporalOrder$response == temporalOrder$foil2Pos] <- 'Foil 2'
  temporalOrder$choice <- choice
  
  ############
  # Room type question
  roomType      <- subset(tempDF, test_part == 'roomType')
  roomType$rt   <- as.numeric(as.character(roomType$rt))
  
  # get trialinfo and add to roomType
  cond               <- roomType$condition[1] + 1 # to correct for difference
  roomType$roomType  <- get(paste0("trials_cond", cond))$roomType
  
  corr_room <- rep(NA, nrow(roomType))
  corr_room[roomType$roomType  == "nw"] <- 1
  corr_room[roomType$roomType  == "ww"] <- 2
  roomType$corr_room <- corr_room
  
  # Calculate accuracy
  accuracy <- rep(NA, dim(roomType)[1])
  accuracy[roomType$response == roomType$corr_room] <- 1
  accuracy[roomType$response != roomType$corr_room] <- 0
  roomType$accuracy <- accuracy
  
  ############
  # Table question
  tableNum      <- subset(tempDF, test_part == 'tableNum')
  tableNum$rt   <- as.numeric(as.character(tableNum$rt))
  
  # Recode keypresses
  response      <- rep(NA, dim(tableNum)[1])
  response[tableNum$key_press == 49] <- 3 # for key press 1
  response[tableNum$key_press == 50] <- 2 # for key press 2
  tableNum$response                  <- response
  
  # Calculate accuracy
  accuracy <- rep(NA, dim(tableNum)[1])
  accuracy[tableNum$response == tableNum$corr_resp] <- 1
  accuracy[tableNum$response != tableNum$corr_resp] <- 0
  tableNum$accuracy <- accuracy
  
  # Create or bind to data.frame
  if(i == 1){
    df_order_b2    <- temporalOrder
    df_order_b2$id <- i
    df_room_b2     <- roomType
    df_room_b2$id  <- i
    df_table_b2    <- tableNum
    df_table_b2$id <- i
  } else {
    temporalOrder$id <- i
    df_order_b2      <- rbind(df_order_b2, temporalOrder)
    roomType$id      <- i
    df_room_b2       <- rbind(df_room_b2, roomType)
    tableNum$id      <- i
    df_table_b2      <- rbind(df_table_b2, tableNum)
  }
}

# Convert to id factor
df_order_b2$id <- as.factor(df_order_b2$id)
df_room_b2$id  <- as.factor(df_room_b2$id)
df_table_b2$id <- as.factor(df_table_b2$id)

# Recode factor levels
levels(df_order_b2$context) <- c('across', 'within-open plane', 'within-M-shape')

# Calculate mean accuracy
agg_order_b2 <- ddply(df_order_b2, c('id', 'context'), summarise, acc = mean(accuracy), rt = mean(rt))
agg_room_b2  <- ddply(df_room_b2, c('id'), summarise, acc = mean(accuracy))
agg_table_b2 <- ddply(df_table_b2, c('id'), summarise, acc = mean(accuracy))

# Transform accuracy
agg_order_b2$trans_acc <- arcsine_transform(agg_order_b2$acc)
agg_room_b2$trans_acc  <- arcsine_transform(agg_room_b2$acc)
agg_table_b2$trans_acc <- arcsine_transform(agg_table_b2$acc)

# Rename factor
agg_order_b2$boundary <- ifelse(agg_order_b2$context == 'across', 'across', 'within')
agg_order_b2$Condition <- 'across'
agg_order_b2$Condition[agg_order_b1$context == 'within-open plane'] <- 'O-room'
agg_order_b2$Condition[agg_order_b1$context == 'within-M-shape']    <- 'M-room'

# Get trial number etc. 
exp1b_trials     <- ddply(df_order_b2, c('id','condition', 'context'), summarise, n = length(id))
exp1b_trials_agg <- ddply(exp1b_trials, c('condition', 'context'), summarise, n = mean(n))
```


```{r exp1_batch2_plot1}
# /* 
# ----------------------------- Exp 1 Batch 2: Plots ---------------------------
# */
plt1 <- ggplot(agg_order_b2, aes(x = boundary, y = acc, group = Condition, colour = Condition)) + 
  geom_boxplot(alpha = 0.5,outlier.shape = NA, key_glyph = "rect") + 
  geom_point(position = position_jitterdodge(jitter.width = 0.2)) + 
  geom_hline(yintercept = 1/3) +
  stat_summary(geom = "point", fun = "mean", col = 'black', size = 3, shape = 24, aes(fill = Condition),
               position=position_dodge(width =  0.75),
               key_glyph = "rect") + 
  geom_segment(aes(x = 1.5, xend = 1.5, y= 0.1, yend= 1/3),colour = 'black',
               arrow = arrow(length = unit(0.30,"cm"), type = "closed"), show.legend = FALSE) +
  annotate('text', x = 1.5, y = 0.1 - 0.03, label = 'Chance') +
  scale_color_mrc(palette = 'secondary') + 
  scale_fill_mrc(palette = 'secondary') +
  labs(y = '3AFC accuracy', x = "Boundary", title = 'Temporal Order') + 
  theme(legend.justification = c(0, 1), 
        legend.position = c(0, 1),
        legend.title = element_text(size = 10),
        legend.text = element_text(size = 9),
        legend.key.size = unit(0.5,"line"))

# Bind room and table together
roomTable_b2 <- data.frame(id = rep(1:n, 2),
                           Type = rep(c('Room', 'Table'), each = n),
                           acc = c(agg_room_b2$acc, agg_table_b2$acc),
                           trans_acc = c(agg_room_b2$trans_acc, agg_table_b2$trans_acc))

plt2 <- ggplot(roomTable_b2, aes(x = Type, y = acc)) + 
  geom_boxplot(alpha = 0.5,outlier.shape = NA) + 
  geom_jitter(width = 0.1, height = 0) +
  geom_hline(yintercept = 0.5) +
  stat_summary(geom = "point", fun = "mean", col = 'black', size = 3, shape = 24, fill = 'red') +
  geom_segment(aes(x = 1.5, xend = 1.5, y= 0.3, yend= 0.5),colour = 'black',
               arrow = arrow(length = unit(0.30,"cm"), type = "closed"), show.legend = FALSE) +
  annotate('text', x = 1.5, y = 0.3 - 0.03, label = 'Chance') +
  labs(y = '2AFC accuracy', x = "Memory type", title = 'Room type and table')

# Combine 2 1 figure
plot_grid(plt1, plt2)
```

```{r exp1_batch2_test1}
# Temporal order question
# Overall memory performance
agg_order_overall_b2           <- ddply(df_order_b2, c('id'), summarise, acc = mean(accuracy), rt = mean(rt))
agg_order_overall_b2$trans_acc <- arcsine_transform(agg_order_overall_b2$acc)

test1 <- ttestBF(agg_order_overall_b2$trans_acc - arcsine_transform(1/3), nullInterval = c(-Inf, 0))
test1 <- reportBF(1/test1[2])

# Examine the boundary effect
## Memory
### Across versus M-room
val1  <- agg_order_b2[agg_order_b2$Condition == 'across', 'trans_acc']
val2  <- agg_order_b2[agg_order_b2$boundary  == 'within' & agg_order_b2$Condition  == 'M-room', 'trans_acc']
test2 <- ttestBF(val1, val2, paired = TRUE, nullInterval = c(-Inf, 0))
test2 <- reportBF(1/test2[1])

### Across versus O-room
val1  <- agg_order_b2[agg_order_b2$Condition == 'across', 'trans_acc']
val2  <- agg_order_b2[agg_order_b2$boundary  == 'within' & agg_order_b2$Condition  == 'O-room', 'trans_acc']
test3 <- ttestBF(val1, val2, paired = TRUE, nullInterval = c(-Inf, 0))
test3 <- reportBF(1/test3[1])

## RT
### Across versus M-room
val1  <- agg_order_b2[agg_order_b2$Condition == 'across', 'rt']
val2  <- agg_order_b2[agg_order_b2$boundary  == 'within' & agg_order_b2$Condition  == 'M-room', 'rt']
test4 <- ttestBF(val1, val2, paired = TRUE, nullInterval = c(-Inf, 0))
test4 <- reportBF(1/test4[2])

### Across versus O-room
val1  <- agg_order_b2[agg_order_b2$Condition == 'across', 'rt']
val2  <- agg_order_b2[agg_order_b2$boundary  == 'within' & agg_order_b2$Condition  == 'O-room', 'rt']
test5 <- ttestBF(val1, val2, paired = TRUE, nullInterval = c(-Inf, 0))
test5 <- reportBF(1/test5[2])

# Room question
test6 <- ttestBF(agg_room_b2$trans_acc - arcsine_transform(0.5), nullInterval = c(-Inf, 0))
test6 <- reportBF(1/test6[2])

# Table question
test7 <- ttestBF(agg_table_b2$trans_acc - arcsine_transform(0.5), nullInterval = c(-Inf, 0))
test7 <- reportBF(test7[2])
```

There was again weak evidence that memory performance was not above chance ($BF_{01}$ = `r test1`) for the temporal memory question. Furthermore, I did not find a boundary effect for M-rooms (across vs. within) for accuracy, $BF_{01}$ = `r test2`, and for RT, $BF_{01}$ = `r test4`, but I did not find an effect for O-rooms for accuracy, $BF_{01}$ = `r test3`, and for RT, $BF_{01}$ = `r test5`. 

Participants also did not show above chance performance for remembering in which room type a cue object was presented in ($BF_{01}$ = `r test6`). However, there was stronger evidence that participants did remember on which table type a cue object was presented ($BF_{10}$ = `r test7`).

#### Discussion
Unfortunately, I again failed to find a boundary effect even for O-rooms. In addition, with the exception of memory for the table question, memory performance was not above chance. Once possible reason of why memory performance was so bad was that in contrast to Horner et al. (2016) I always selected foils +/-4 positions away from the target while Horner and colleagues selected random foils.  Another option could be to use a more semantic task as such a pleasant/unpleasant judgement could be made, however I was concerned that most objects are fairly neutral making this task not meaningful. 

### Batch 3
#### Sample
```{r exp1_batch3_demographics}
# Load data
exp1c_demographics <- read.table("~/boundaryVR/data/Exp1/batch3/exp1c_demographics.csv", header = TRUE, sep = ',')

# Exclude returned (not approved)
exp1c_demographics <- exp1c_demographics[exp1c_demographics$status != 'RETURNED', ]

# Create strings
str1      <- mean_SD_str2(exp1c_demographics$age, 1)
sex_table <- table(droplevels.factor(exp1c_demographics$Sex))
```

Due to technical problems, some prolific submissions were not usable. Unfortunately, the data containing the prolific IDs were deleted so that it not possible anymore to retrieve the demographical data only for those data that remained in the final sample of 13 participants. These came from a population of 31 (`r sex_table[1]` female and `r sex_table[2]` male). Their mean age was `r str1` years.

#### Description of memory task
Since memory performance was not above chance in batch 1 & batch 2, I decided to run another batch of participants but this time having the same foil (random) selection procedure as Horner et al (2016) with the hope that this would improve memory performance. 

<!-- describe exact selection  -->

#### Results
```{r exp1_batch3_loadData}
# Load all data
prefix         <- '~/boundaryVR/data/Exp1/batch3/memoryTask/'
allFiles       <- list.files(paste(prefix, sep = ''))
allFiles_paths <- paste(prefix, allFiles, sep = '')
n              <- length(allFiles_paths)

# Load trial information
load("~/boundaryVR/experiments/Exp1/batch3/r_supportFiles/trialData_randomFoils.RData")
# Note that counterbalancing in that images goes from 1 to 8, while it goes from 0 to 7 in the javascript
# files.

# Order trial information
# Due to an error only 78 trials were tested during 
trials_cond5 <- trials_cond5[order(trials_cond5$objNum),][1:78,]
trials_cond6 <- trials_cond6[order(trials_cond6$objNum),][1:78,]
trials_cond7 <- trials_cond7[order(trials_cond7$objNum),][1:78,]
trials_cond8 <- trials_cond8[order(trials_cond8$objNum),][1:78,]

for(i in 1:n){
  ############
  # Loading daya
  tempDF <- read.csv(allFiles_paths[i], header = TRUE, na.strings = '')
  
  # Recode key presses
  response      <- rep(NA, dim(tempDF)[1])
  response[tempDF$key_press == 49] <- 1
  response[tempDF$key_press == 50] <- 2
  response[tempDF$key_press == 51] <- 3
  tempDF$response                  <- response
  
  ############
  # Temporal order memory
  temporalOrder <- subset(tempDF, test_part == 'temporalOrder')
  
  # Sort by objectNumber
  temporalOrder <- temporalOrder[order(temporalOrder$probe),]
  
  # get trialinfo and add to temporalOrder
  cond <- temporalOrder$condition[1] + 1 # to correct for difference
  temporalOrder$foil1Pos <- get(paste0("trials_cond", cond))$foil1Pos
  temporalOrder$foil2Pos <- get(paste0("trials_cond", cond))$foil2Pos
  
  temporalOrder$rt <- as.numeric(as.character(temporalOrder$rt))

  # Calcalate accuracy 
  accuracy <- rep(NA, dim(temporalOrder)[1])
  accuracy[temporalOrder$response == temporalOrder$corr_resp] <- 1
  accuracy[temporalOrder$response != temporalOrder$corr_resp] <- 0
  temporalOrder$accuracy <- accuracy
  
  # Create variable that desribe whether target, foil1, foil2 was choosen
  choice <- rep('Target', dim(temporalOrder)[1])
  choice[temporalOrder$response == temporalOrder$foil1Pos] <- 'Foil 1'
  choice[temporalOrder$response == temporalOrder$foil2Pos] <- 'Foil 2'
  temporalOrder$choice <- choice
  
  ############
  # Room type question
  roomType      <- subset(tempDF, test_part == 'roomType')
  roomType$rt   <- as.numeric(as.character(roomType$rt))
  
  # get trialinfo and add to roomType
  roomType$roomType  <- get(paste0("trials_cond", cond))$roomType
  
  corr_room <- rep(NA, nrow(roomType))
  corr_room[roomType$roomType  == "nw"] <- 1
  corr_room[roomType$roomType  == "ww"] <- 2
  roomType$corr_room <- corr_room
  
  # Calculate accuracy
  accuracy <- rep(NA, dim(roomType)[1])
  accuracy[roomType$response == roomType$corr_room] <- 1
  accuracy[roomType$response != roomType$corr_room] <- 0
  roomType$accuracy <- accuracy
  
  # Adding table information to temporal order memory
  # Get right information and create temp variable
  tempInfo      <- get(paste0("trials_cond",  temporalOrder$condition[1]))
  tempInfo_full <- get(paste0("trials_cond",  temporalOrder$condition[1], '_full'))
  # Order both data frames by objNum/probe
  tempInfo <- tempInfo[1:78, ] # Because of an error in the code only 78 trials exist per participant
  tempInfo <- tempInfo[order(tempInfo$objNum),]
  temporalOrder <- temporalOrder[order(temporalOrder$probe),]
  
  # Transfering information between dfs
  temporalOrder$probeTable <- tempInfo$table
  # Loop through df to get table of target, foil1 and foil2
  targetTable <- c()
  foil1Table  <- c()
  foil2Table  <- c()
  for(j in 1:dim(tempInfo)[1]){
    targetTable[j] <- tempInfo_full[tempInfo_full$objNum == tempInfo$target[j], 'table']
    foil1Table[j]  <- tempInfo_full[tempInfo_full$objNum == tempInfo$foil1[j], 'table']
    foil2Table[j]  <- tempInfo_full[tempInfo_full$objNum == tempInfo$foil2[j], 'table']
  }
  
  # Add the information to main data.frame
  temporalOrder$targetTable <- targetTable
  temporalOrder$foil1Table  <- foil1Table
  temporalOrder$foil2Table  <- foil2Table
  
  ############
  # Table question
  tableNum      <- subset(tempDF, test_part == 'tableNum')
  tableNum$rt   <- as.numeric(as.character(tableNum$rt))
  
  # Recode keypresses
  response      <- rep(NA, dim(tableNum)[1])
  response[tableNum$key_press == 49] <- 3 # for key press 1
  response[tableNum$key_press == 50] <- 2 # for key press 2
  tableNum$response                  <- response
  
  # Calculate accuracy
  accuracy <- rep(NA, dim(tableNum)[1])
  accuracy[tableNum$response == tableNum$corr_resp] <- 1
  accuracy[tableNum$response != tableNum$corr_resp] <- 0
  tableNum$accuracy <- accuracy
  
  # Create or bind to data.frame
  if(i == 1){
    df_order_b3    <- temporalOrder
    df_order_b3$id <- i
    df_room_b3     <- roomType
    df_room_b3$id  <- i
    df_table_b3    <- tableNum
    df_table_b3$id <- i
  } else {
    temporalOrder$id <- i
    df_order_b3      <- rbind(df_order_b3, temporalOrder)
    roomType$id      <- i
    df_room_b3       <- rbind(df_room_b3, roomType)
    tableNum$id      <- i
    df_table_b3      <- rbind(df_table_b3, tableNum)
  }
}

# Convert to id factor
df_order_b3$id <- as.factor(df_order_b3$id)
df_room_b3$id  <- as.factor(df_room_b3$id)
df_table_b3$id <- as.factor(df_table_b3$id)

# Recode factor levels
levels(df_order_b3$context) <- c('across', 'within-open plane', 'within-M-shape')

# Calculate mean accuracy
agg_order_b3 <- ddply(df_order_b3, c('id', 'context'), summarise, acc = mean(accuracy), rt = mean(rt))
agg_room_b3  <- ddply(df_room_b3, c('id'), summarise, acc = mean(accuracy))
agg_table_b3 <- ddply(df_table_b3, c('id'), summarise, acc = mean(accuracy))

# Transform values
agg_order_b3$trans_acc <- arcsine_transform(agg_order_b3$acc)
agg_room_b3$trans_acc  <- arcsine_transform(agg_room_b3$acc)
agg_table_b3$trans_acc <- arcsine_transform(agg_table_b3$acc)

# Rename factor
agg_order_b3$boundary <- ifelse(agg_order_b3$context == 'across', 'across', 'within')
agg_order_b3$Condition <- 'across'
agg_order_b3$Condition[agg_order_b3$context == 'within-open plane'] <- 'O-room'
agg_order_b3$Condition[agg_order_b3$context == 'within-M-shape']    <- 'M-room'

# Get trial number etc. 
exp1c_trials     <- ddply(df_order_b3, c('id','condition', 'context'), summarise, n = length(id))
exp1c_trials_agg <- ddply(exp1c_trials, c('condition', 'context'), summarise, n = mean(n))
```


```{r foil_distance}
foil_distances <- ddply(df_order_b3, c('worker_id'), summarise, dist1 = mean(dist1), dist2 = mean(dist2))

dist1 <- unique(foil_distances$dist1 + 1) 
dist2 <- unique(foil_distances$dist2 - 1)

#range(dist1)
#range(dist2)
```



```{r exp1_batch3_plot1}
# /* 
# ----------------------------- Exp 1 Batch 3: Plots ---------------------------
# */
plt1 <- ggplot(agg_order_b3, aes(x = boundary, y = acc, group = Condition, colour = Condition)) + 
  geom_boxplot(alpha = 0.5,outlier.shape = NA, key_glyph = "rect") + 
  geom_point(position = position_jitterdodge(jitter.width = 0.2)) + 
  geom_hline(yintercept = 1/3) +
  stat_summary(geom = "point", fun = "mean", col = 'black', size = 3, shape = 24, aes(fill = Condition),
               position=position_dodge(width =  0.75),
               key_glyph = "rect") + 
  geom_segment(aes(x = 1.5, xend = 1.5, y= 0.1, yend= 1/3),colour = 'black',
               arrow = arrow(length = unit(0.30,"cm"), type = "closed"), show.legend = FALSE) +
  annotate('text', x = 1.5, y = 0.1 - 0.03, label = 'Chance') +
  scale_color_mrc(palette = 'secondary') + 
  scale_fill_mrc(palette = 'secondary') +
  labs(y = '3AFC accuracy', x = "Boundary", title = 'Temporal Order') + 
  theme(legend.justification = c(0, 1), 
        legend.position = c(0, 1),
        legend.title = element_text(size = 10),
        legend.text = element_text(size = 9),
        legend.key.size = unit(0.5,"line"))

# Bind room and table together
roomTable_b3 <- data.frame(id = rep(1:n, 2),
                           Type = rep(c('Room', 'Table'), each = n),
                           acc = c(agg_room_b3$acc, agg_table_b3$acc),
                           trans_acc = c(agg_room_b3$trans_acc, agg_table_b3$trans_acc))

plt2 <- ggplot(roomTable_b3, aes(x = Type, y = acc)) + 
  geom_boxplot(alpha = 0.5,outlier.shape = NA) + 
  geom_jitter(width = 0.1, height = 0) +
  geom_hline(yintercept = 0.5) +
  stat_summary(geom = "point", fun = "mean", col = 'black', size = 3, shape = 24, fill = 'red') +
  geom_segment(aes(x = 1.5, xend = 1.5, y= 0.3, yend = 0.5),colour = 'black',
               arrow = arrow(length = unit(0.30,"cm"), type = "closed"), show.legend = FALSE) +
  annotate('text', x = 1.5, y = 0.3 - 0.03, label = 'Chance') +
  labs(y = '2AFC accuracy', x = "Memory type", title = 'Room type and table')

# Combine 2 1 figure
plot_grid(plt1, plt2)
```

```{r exp1_batch3_test1}
# Temporal order question
# Overall memory performance
agg_order_overall_b3           <- ddply(df_order_b3, c('id'), summarise, acc = mean(accuracy), rt = mean(rt))
agg_order_overall_b3$trans_acc <- arcsine_transform(agg_order_overall_b3$acc)

test1 <- ttestBF(agg_order_overall_b3$trans_acc - arcsine_transform(1/3), nullInterval = c(-Inf, 0))
test1 <- reportBF(test1[2])

# Examine the boundary effect
## Memory
### Across versus M-room
val1  <- agg_order_b3[agg_order_b3$Condition == 'across', 'trans_acc']
val2  <- agg_order_b3[agg_order_b3$boundary  == 'within' & agg_order_b3$Condition  == 'M-room', 'trans_acc']
test2 <- ttestBF(val1, val2, paired = TRUE, nullInterval = c(-Inf, 0))
test2 <- reportBF(test2[1])

### Across versus O-room
val1  <- agg_order_b3[agg_order_b3$Condition == 'across', 'trans_acc']
val2  <- agg_order_b3[agg_order_b3$boundary  == 'within' & agg_order_b3$Condition  == 'O-room', 'trans_acc']
test3 <- ttestBF(val1, val2, paired = TRUE, nullInterval = c(-Inf, 0))
test3 <- reportBF(1/test3[1])

## RT
### Across versus M-room
val1  <- agg_order_b3[agg_order_b3$Condition == 'across', 'rt']
val2  <- agg_order_b3[agg_order_b3$boundary  == 'within' & agg_order_b3$Condition  == 'M-room', 'rt']
test4 <- ttestBF(val1, val2, paired = TRUE, nullInterval = c(-Inf, 0))
test4 <- reportBF(1/test4[2])

### Across versus O-room
val1  <- agg_order_b3[agg_order_b3$Condition == 'across', 'rt']
val2  <- agg_order_b3[agg_order_b3$boundary  == 'within' & agg_order_b3$Condition  == 'O-room', 'rt']
test5 <- ttestBF(val1, val2, paired = TRUE, nullInterval = c(-Inf, 0))
test5 <- reportBF(1/test5[2])

# Room question
test6 <- ttestBF(agg_room_b3$trans_acc - arcsine_transform(0.5), nullInterval = c(-Inf, 0))
test6 <- reportBF(1/test6[2])

# Table question
test7 <- ttestBF(agg_table_b3$trans_acc - arcsine_transform(0.5), nullInterval = c(-Inf, 0))
test7 <- reportBF(test7[2])
```

This time there was strong evidence that memory performance was above chance ($BF_{01}$ = `r test1`) for the temporal memory question. While, I found a boundary effect for M-rooms (across vs. within) for accuracy, $BF_{01}$ = `r test2`, and but not for RT, $BF_{01}$ = `r test4`, but I did not find an effect for O-rooms for accuracy, $BF_{01}$ = `r test3`, and for RT, $BF_{01}$ = `r test5`. 

Participants again did not show above chance performance for remembering in which room type a cue object was presented in ($BF_{01}$ = `r test6`). However, there was strong evidence that participants did remember on which table type a cue object was presented ($BF_{10}$ = `r test7`).

```{r exp1_batch3_test2}
# Collapsing within condition
df_order_b3$context2 <- 'within'
df_order_b3$context2[df_order_b3$context == 'across'] <- 'across'
agg_order_collasp_b3 <- ddply(df_order_b3, c('id',  'context2'), summarise, acc = mean(accuracy))
agg_order_collasp_b3$trans_acc <- arcsine_transform(agg_order_collasp_b3$acc)

# Test
test8 <- ttestBF(agg_order_collasp_b3[agg_order_collasp_b3$context2 == 'across', 4],
                  agg_order_collasp_b3[agg_order_collasp_b3$context2 == 'within', 4],  paired = TRUE)

test8 <- reportBF(test8)

# Effect size
diffScores <- agg_order_collasp_b3[agg_order_collasp_b3$context2 == 'within', 4] -
              agg_order_collasp_b3[agg_order_collasp_b3$context2 == 'across', 4] 
effSize    <- round(mean(diffScores)/sd(diffScores), 2)
```

Interestingly, the difference between condition (across vs. within) collapsed across room type was still large  (BF10 = `r test8`, d = `r effSize`). 

#### Discussion
Relaxing the selection of foils did have the intended effect of improving overall memory performance for temporal order. Surprisingly, I only found a boundary effect for M-room but not for O-rooms. This is surprising as with this pilot I wanted to ascertain that walking through an M-room does not have the same boundary effect that was reported in Horner et al. (2016) for walking through doors with 'normal' rooms. However, I found that a boundary effect for M-rooms but not for O-rooms. To investigate the absence of an boundary effect for O-rooms I designed another experiment, in which participants only saw one type of the rooms. 

# Experiment 2
## Design 
In this version of the task, participants were asked both temporal order question directions (Which object was before? vs. Which object was after?) in a blocked fashion. The order of which was randomised. 

```{r exp2_table0}
table9 <- data.frame(v1 = 1:8,
                     v2 = c('M-room', 'M-room', 'O-room', 'O-room', 'M-room', 'M-room', 'O-room', 'O-room'),
                     v3 = c('within', 'across', 'within', 'across', 'within', 'across', 'within', 'across'),
                     v4 = c(rep('Before', 4), rep('After', 4)),
                     v5 = c(rep('After', 4), rep('Before', 4)))

names(table9) <- c('Condition', 'Room type', 'Start with', 'Block 1', 'Block 2')
kable(table9, format = 'html', caption = "Table 9: Factorial design for Experiment 2")
```

These 8 between-subject conditions were fully crossed: room type (M-room vs. O-room), the fist inter-item connection (within vs. across) and the direction of temporal order memory that is tested first (Which object was before? vs. Which object was after?). To keep the experiment from getting too long, room type and table type questions were scraped as sufficient evidence was found that participants can only remember on which table an object was. 

Small changes were made to the lighting in the rooms making it faster to random and look more realistic. Furthermore, camera movement was now scripted instead of generated by me through navigating through the rooms myself and capturing the screen. Also made small changes were made to objects with regards to their colour and size. A few objects were also swapped because they were reported to be difficult to recognise.  

<!-- Update log and specify which objects. Also create list of objects -->

## Design analysis of sequential data collection
Since I did find a difference between across and within room associations for M-rooms but not for O-rooms, I focussed on finding a boundary effect for O-rooms. To collect data efficiently, data was collected sequentially for Experiment 2. The data collection plan was as follows:

> At first, I will run twelve participants for the O-room, after which I will check the evidence whether there is a difference between across and within room associations. I will increase the sample size by increments of four until we either reach a $BF_{10}$ of 6 or 1/6 or the maximum sample size of 36 that is currently constrained by our remaining balance on prolific (£431.66). If I find evidence for a boundary effect for O-rooms, I will do the same for M-rooms (starting at twelve and incrementing by four) until I reach a criterion. In case, I obtain an inconclusive results for the O-rooms and I still have resources left, I will increase the sample size for O-rooms and vice versa for M-rooms. 

Note that the maximal sample size of later increased to 51 (per room) as the experiment was shorter than expected. 

In order to assess whether this data collection plan had enough chance to provide conclusive evidence ($BF_{10}$ > 6 | < 1/6), I ran a simplified simulation with directional Bayesian _t_-tests with minimum sample size of twelve and maximum of 36 with effect sizes d = 0, 0.44 and 0.78 that correspond to a null effect and effect sizes that we observed in Experiment 1 Batch 3. 

```{r exp2_loadData_designAnalysis}
# Load data
load("analysis/powerAnalysis_Exp2_2.RData")
```


```{r exp2_designAnalysis_plotParameters}
# For plotting
minN         <- 12
maxN         <- 36
barWidth     <- 0.9
panMar       <- 0.1
bar_yAxis    <- 0.7
hist_yAxis   <- 2900
middle_xlim  <- c(-5.5, 5.5)
crit1        <- 6
crit2        <- 1/6
breaksVal    <- c(-5, -2, 0, 2, 5)
breaksLab    <- c('1/6', '1/3', '1', '3', '6')
```

### Null effect
```{r exp2_designAnalysis_plot1}
# Input for plot
plot_caption   <- expression("A) Simulation for d"[true]*" = 0.00")
da_sim_results <- df_H0

############################
# Preparation of data
da_sim_results$trans_bf <- NA
da_sim_results$trans_bf[da_sim_results$bf < 1] <- -1/da_sim_results$bf[da_sim_results$bf < 1] + 1
da_sim_results$trans_bf[da_sim_results$bf > 1] <- da_sim_results$bf[da_sim_results$bf > 1] - 1

da_sim_results_agg <- ddply(da_sim_results, c('id'), summarise, n = n[length(n)], bf = bf[length(bf)])
da_sim_results_agg$support <- 'undecided'
da_sim_results_agg$support[da_sim_results_agg$bf > crit1] <- 'H1'
da_sim_results_agg$support[da_sim_results_agg$bf < crit2] <- 'H0'

# Creates band
da_sim_results_agg$band                                           <- '> 10'
da_sim_results_agg$band[da_sim_results_agg$bf < 10 & da_sim_results_agg$bf > 6]     <- '> 6'
da_sim_results_agg$band[da_sim_results_agg$bf < 6 & da_sim_results_agg$bf > 3]      <- '> 3'
da_sim_results_agg$band[da_sim_results_agg$bf < 3 & da_sim_results_agg$bf > 1]      <- '> 1'
da_sim_results_agg$band[da_sim_results_agg$bf < 1 & da_sim_results_agg$bf > 1/3]    <- '< 1'
da_sim_results_agg$band[da_sim_results_agg$bf < 1/3 & da_sim_results_agg$bf > 1/6]  <- '< 1/3'
da_sim_results_agg$band[da_sim_results_agg$bf < 1/6 & da_sim_results_agg$bf > 1/10] <- '< 1/6'
da_sim_results_agg$band[da_sim_results_agg$bf < 1/10]                      <- '< 1/10'

# Create factor band
da_sim_results_agg$band <- factor(da_sim_results_agg$band, levels = c('> 10', '> 6', '> 3', '> 1', '< 1', '< 1/3', '< 1/6', '< 1/10'))


# Get back to main DF
da_sim_results$band <- rep(da_sim_results_agg$band, table(da_sim_results$id))


# DF for upper histogram
da_sim_results_agg_supp_H1 <- ddply(subset(da_sim_results_agg, support == 'H1'),
                           c('n', 'band'),
                           summarise,
                           freq = length(bf)/nIter)

# DF for right histogram
da_sim_results_agg_undecided <- subset(da_sim_results_agg, da_sim_results_agg$n == maxN & da_sim_results_agg$bf < crit1 & da_sim_results_agg$bf > crit2)
da_sim_results_agg_undecided$trans_bf <- NA
da_sim_results_agg_undecided$trans_bf[da_sim_results_agg_undecided$bf < 1] <- -1/da_sim_results_agg_undecided$bf[da_sim_results_agg_undecided$bf < 1] + 1
da_sim_results_agg_undecided$trans_bf[da_sim_results_agg_undecided$bf > 1] <- da_sim_results_agg_undecided$bf[da_sim_results_agg_undecided$bf > 1] - 1

# DF for lower histrogram
da_sim_results_agg_supp_H0 <- ddply(subset(da_sim_results_agg, support == 'H0'),
                           c('n', 'band'),
                           summarise,
                           freq = length(bf)/nIter)

# If there are no values for this
if(nrow(da_sim_results_agg_supp_H0) == 0){
  da_sim_results_agg_supp_H0 <- data.frame(n = seq(minN, maxN, batchSize),
                                  band = rep('< 1/10', 5),
                                  freq = rep(0, 5))
}


# Upper Histogram
upper_hist <- ggplot(da_sim_results_agg_supp_H1, aes(x = n, y = freq, fill = band)) + 
  geom_bar(stat = "identity", show.legend = FALSE, alpha = 0.5, width = barWidth)  +
  scale_fill_BF() +
  coord_cartesian(ylim = c(0, bar_yAxis), xlim = c(minN - 0.5, maxN + 0.5), expand = FALSE) +
  labs(y = 'Frequency', x = plot_caption) +
  scale_x_continuous(position = 'top') + 
  theme(axis.title.x = element_text(colour = "black", size = 20),
        axis.text.x = element_text(colour = "white"),
        axis.ticks.x = element_line(colour = "white"),
        plot.margin = unit(c(panMar, panMar, panMar, 0), "cm"))

# Create line plot
linePlot <- ggplot(da_sim_results, aes(x = n, y = trans_bf, group = id, colour = band)) + 
  geom_line(alpha = 0.05, show.legend = FALSE) + 
  scale_colour_BF() +
  geom_hline(yintercept = 5) +
  geom_hline(yintercept = -5) +
  scale_y_continuous(breaks = breaksVal,
                     labels = breaksLab) +
  coord_cartesian(xlim = c(minN, maxN), ylim = middle_xlim, expand = FALSE) +
  labs(y = expression(BF[10]), x = NULL) +
  theme(axis.title.x = element_blank(),
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        plot.margin = unit(c(panMar, panMar, panMar, 0), "cm"))

# Create right histogram
right_hist <- ggplot(da_sim_results_agg_undecided, aes(x = trans_bf, fill = band)) +
  coord_flip(ylim = c(0, hist_yAxis), xlim = middle_xlim, expand = FALSE) +
  geom_histogram(alpha = 0.5, show.legend = FALSE) +
  scale_fill_BF(drop = FALSE) +
  labs(y = 'Count', x = NULL) +
  theme(axis.title.y = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        axis.title.x = element_blank(),
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        plot.margin = unit(c(panMar, panMar, panMar, 0), "cm"))

# Create lower histogram
lower_hist <- ggplot(da_sim_results_agg_supp_H0, aes(x = n, y = freq, fill = band)) + 
  scale_y_reverse() +
  scale_fill_BF(drop = F) +
  geom_bar(stat = "identity", show.legend = FALSE, alpha = 0.5, width = barWidth) + 
  labs(y = 'Frequency', x = 'Sample size') +
  coord_cartesian(ylim = c(bar_yAxis, 0), xlim = c(minN -0.5, maxN + 0.5), expand = FALSE) +
  theme(plot.margin = unit(c(panMar, panMar, panMar, 0), "cm"))


# Combine everything into one plot
## Get Grobs
gplot1 <- ggplotGrob(upper_hist)
gplot2 <- ggplotGrob(linePlot)
gplot3 <- ggplotGrob(right_hist) 
gplot4 <- ggplotGrob(lower_hist)

## Get gtables
gt_gplot1  <- gtable_frame(gplot1,  width = unit(12, "null"))
gt_gplot2  <- gtable_frame(gplot2,  width = unit(12, "null"))
gt_gplot3  <- gtable_frame(gplot3,  width = unit(3, "null"))
gt_gplot4  <- gtable_frame(gplot4,  width = unit(12, "null"))
gt_gBlank2 <- gtable_frame(gBlank2, width = unit(3, "null"))

## Combine components
gt_upper   <- gtable_frame(gtable_cbind(gt_gplot1, gt_gBlank2)) 
gt_middle  <- gtable_frame(gtable_cbind(gt_gplot2, gt_gplot3))
gt_lower   <- gtable_frame(gtable_cbind(gt_gplot4, gt_gBlank2))

## Combine into 1 plot
gtable_combined1 <- gtable_frame(gtable_rbind(gt_upper, gt_middle, gt_lower))
```

```{r exp2_designAnalysis_table1}
table10 <- as.data.frame(table(df_H0_agg$band)/nIter)
names(table10) <- c('Support', 'Percent')
#kable(table10, format = 'html', caption = "Table 10: Results of simulation for null effect")
```

### Effect size similar to boundary effect for O-rooms
```{r exp2_designAnalysis_plot2}
# Input for plot
plot_caption   <- expression("B) Simulation for d"[true]*" = 0.44")
da_sim_results <- df_H1

############################
# Preparation of data
da_sim_results$trans_bf <- NA
da_sim_results$trans_bf[da_sim_results$bf < 1] <- -1/da_sim_results$bf[da_sim_results$bf < 1] + 1
da_sim_results$trans_bf[da_sim_results$bf > 1] <- da_sim_results$bf[da_sim_results$bf > 1] - 1

da_sim_results_agg <- ddply(da_sim_results, c('id'), summarise, n = n[length(n)], bf = bf[length(bf)])
da_sim_results_agg$support <- 'undecided'
da_sim_results_agg$support[da_sim_results_agg$bf > crit1] <- 'H1'
da_sim_results_agg$support[da_sim_results_agg$bf < crit2] <- 'H0'

# Creates band
da_sim_results_agg$band                                           <- '> 10'
da_sim_results_agg$band[da_sim_results_agg$bf < 10 & da_sim_results_agg$bf > 6]     <- '> 6'
da_sim_results_agg$band[da_sim_results_agg$bf < 6 & da_sim_results_agg$bf > 3]      <- '> 3'
da_sim_results_agg$band[da_sim_results_agg$bf < 3 & da_sim_results_agg$bf > 1]      <- '> 1'
da_sim_results_agg$band[da_sim_results_agg$bf < 1 & da_sim_results_agg$bf > 1/3]    <- '< 1'
da_sim_results_agg$band[da_sim_results_agg$bf < 1/3 & da_sim_results_agg$bf > 1/6]  <- '< 1/3'
da_sim_results_agg$band[da_sim_results_agg$bf < 1/6 & da_sim_results_agg$bf > 1/10] <- '< 1/6'
da_sim_results_agg$band[da_sim_results_agg$bf < 1/10]                      <- '< 1/10'

# Create factor band
da_sim_results_agg$band <- factor(da_sim_results_agg$band, levels = c('> 10', '> 6', '> 3', '> 1', '< 1', '< 1/3', '< 1/6', '< 1/10'))


# Get back to main DF
da_sim_results$band <- rep(da_sim_results_agg$band, table(da_sim_results$id))


# DF for upper histogram
da_sim_results_agg_supp_H1 <- ddply(subset(da_sim_results_agg, support == 'H1'),
                           c('n', 'band'),
                           summarise,
                           freq = length(bf)/nIter)

# DF for right histogram
da_sim_results_agg_undecided <- subset(da_sim_results_agg, da_sim_results_agg$n == maxN & da_sim_results_agg$bf < crit1 & da_sim_results_agg$bf > crit2)
da_sim_results_agg_undecided$trans_bf <- NA
da_sim_results_agg_undecided$trans_bf[da_sim_results_agg_undecided$bf < 1] <- -1/da_sim_results_agg_undecided$bf[da_sim_results_agg_undecided$bf < 1] + 1
da_sim_results_agg_undecided$trans_bf[da_sim_results_agg_undecided$bf > 1] <- da_sim_results_agg_undecided$bf[da_sim_results_agg_undecided$bf > 1] - 1

# DF for lower histrogram
da_sim_results_agg_supp_H0 <- ddply(subset(da_sim_results_agg, support == 'H0'),
                           c('n', 'band'),
                           summarise,
                           freq = length(bf)/nIter)

# If there are no values for this
if(nrow(da_sim_results_agg_supp_H0) == 0){
  da_sim_results_agg_supp_H0 <- data.frame(n = seq(minN, maxN, batchSize),
                                  band = rep('< 1/10', 5),
                                  freq = rep(0, 5))
}


# Upper Histogram
upper_hist <- ggplot(da_sim_results_agg_supp_H1, aes(x = n, y = freq, fill = band)) + 
  geom_bar(stat = "identity", show.legend = FALSE, alpha = 0.5, width = barWidth)  +
  scale_fill_BF() +
  coord_cartesian(ylim = c(0, bar_yAxis), xlim = c(minN - 0.5, maxN + 0.5), expand = FALSE) +
  labs(y = 'Frequency', x = plot_caption) +
  scale_x_continuous(position = 'top') + 
  theme(axis.title.x = element_text(colour = "black", size = 20),
        axis.text.x = element_text(colour = "white"),
        axis.ticks.x = element_line(colour = "white"),
        plot.margin = unit(c(panMar, panMar, panMar, 0), "cm"))

# Create line plot
linePlot <- ggplot(da_sim_results, aes(x = n, y = trans_bf, group = id, colour = band)) + 
  geom_line(alpha = 0.05, show.legend = FALSE) + 
  scale_colour_BF() +
  geom_hline(yintercept = 5) +
  geom_hline(yintercept = -5) +
  scale_y_continuous(breaks = breaksVal,
                     labels = breaksLab) +
  coord_cartesian(xlim = c(minN, maxN), ylim = middle_xlim, expand = FALSE) +
  labs(y = expression(BF[10]), x = NULL) +
  theme(axis.title.x = element_blank(),
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        plot.margin = unit(c(panMar, panMar, panMar, 0), "cm"))

# Create right histogram
right_hist <- ggplot(da_sim_results_agg_undecided, aes(x = trans_bf, fill = band)) +
  coord_flip(ylim = c(0, hist_yAxis), xlim = middle_xlim, expand = FALSE) +
  geom_histogram(alpha = 0.5, show.legend = FALSE) +
  scale_fill_BF(drop = FALSE) +
  labs(y = 'Count', x = NULL) +
  theme(axis.title.y = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        axis.title.x = element_blank(),
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        plot.margin = unit(c(panMar, panMar, panMar, 0), "cm"))

# Create lower histogram
lower_hist <- ggplot(da_sim_results_agg_supp_H0, aes(x = n, y = freq, fill = band)) + 
  scale_y_reverse() +
  scale_fill_BF(drop = F) +
  geom_bar(stat = "identity", show.legend = FALSE, alpha = 0.5, width = barWidth) + 
  labs(y = 'Frequency', x = 'Sample size') +
  coord_cartesian(ylim = c(bar_yAxis, 0), xlim = c(minN -0.5, maxN + 0.5), expand = FALSE) +
  theme(plot.margin = unit(c(panMar, panMar, panMar, 0), "cm"))


# Combine everything into one plot
## Get Grobs
gplot1 <- ggplotGrob(upper_hist)
gplot2 <- ggplotGrob(linePlot)
gplot3 <- ggplotGrob(right_hist) 
gplot4 <- ggplotGrob(lower_hist)

## Get gtables
gt_gplot1  <- gtable_frame(gplot1,  width = unit(12, "null"))
gt_gplot2  <- gtable_frame(gplot2,  width = unit(12, "null"))
gt_gplot3  <- gtable_frame(gplot3,  width = unit(3, "null"))
gt_gplot4  <- gtable_frame(gplot4,  width = unit(12, "null"))
gt_gBlank2 <- gtable_frame(gBlank2, width = unit(3, "null"))

## Combine components
gt_upper   <- gtable_frame(gtable_cbind(gt_gplot1, gt_gBlank2)) 
gt_middle  <- gtable_frame(gtable_cbind(gt_gplot2, gt_gplot3))
gt_lower   <- gtable_frame(gtable_cbind(gt_gplot4, gt_gBlank2))

## Combine into 1 plot
gtable_combined2 <- gtable_frame(gtable_rbind(gt_upper, gt_middle, gt_lower))
```

```{r exp2_designAnalysis_table2}
table11 <- as.data.frame(table(df_H1_agg$band)/nIter)
names(table11) <- c('Support', 'Percent')
#kable(table11, format = 'html', caption = "Table 11: Results of simulation for effect size similar to open-plane room (within vs. across)")
```

### Effect size similar to boundary effect for M-rooms
```{r exp2_designAnalysis_plot3}
# Input for plot
plot_caption   <- expression("C) Simulation for d"[true]*" = 0.78")
da_sim_results <- df_H2

############################
# Preparation of data
da_sim_results$trans_bf <- NA
da_sim_results$trans_bf[da_sim_results$bf < 1] <- -1/da_sim_results$bf[da_sim_results$bf < 1] + 1
da_sim_results$trans_bf[da_sim_results$bf > 1] <- da_sim_results$bf[da_sim_results$bf > 1] - 1

da_sim_results_agg <- ddply(da_sim_results, c('id'), summarise, n = n[length(n)], bf = bf[length(bf)])
da_sim_results_agg$support <- 'undecided'
da_sim_results_agg$support[da_sim_results_agg$bf > crit1] <- 'H1'
da_sim_results_agg$support[da_sim_results_agg$bf < crit2] <- 'H0'

# Creates band
da_sim_results_agg$band                                           <- '> 10'
da_sim_results_agg$band[da_sim_results_agg$bf < 10 & da_sim_results_agg$bf > 6]     <- '> 6'
da_sim_results_agg$band[da_sim_results_agg$bf < 6 & da_sim_results_agg$bf > 3]      <- '> 3'
da_sim_results_agg$band[da_sim_results_agg$bf < 3 & da_sim_results_agg$bf > 1]      <- '> 1'
da_sim_results_agg$band[da_sim_results_agg$bf < 1 & da_sim_results_agg$bf > 1/3]    <- '< 1'
da_sim_results_agg$band[da_sim_results_agg$bf < 1/3 & da_sim_results_agg$bf > 1/6]  <- '< 1/3'
da_sim_results_agg$band[da_sim_results_agg$bf < 1/6 & da_sim_results_agg$bf > 1/10] <- '< 1/6'
da_sim_results_agg$band[da_sim_results_agg$bf < 1/10]                      <- '< 1/10'

# Create factor band
da_sim_results_agg$band <- factor(da_sim_results_agg$band, levels = c('> 10', '> 6', '> 3', '> 1', '< 1', '< 1/3', '< 1/6', '< 1/10'))


# Get back to main DF
da_sim_results$band <- rep(da_sim_results_agg$band, table(da_sim_results$id))


# DF for upper histogram
da_sim_results_agg_supp_H1 <- ddply(subset(da_sim_results_agg, support == 'H1'),
                           c('n', 'band'),
                           summarise,
                           freq = length(bf)/nIter)

# DF for right histogram
da_sim_results_agg_undecided <- subset(da_sim_results_agg, da_sim_results_agg$n == maxN & da_sim_results_agg$bf < crit1 & da_sim_results_agg$bf > crit2)
da_sim_results_agg_undecided$trans_bf <- NA
da_sim_results_agg_undecided$trans_bf[da_sim_results_agg_undecided$bf < 1] <- -1/da_sim_results_agg_undecided$bf[da_sim_results_agg_undecided$bf < 1] + 1
da_sim_results_agg_undecided$trans_bf[da_sim_results_agg_undecided$bf > 1] <- da_sim_results_agg_undecided$bf[da_sim_results_agg_undecided$bf > 1] - 1

# DF for lower histrogram
da_sim_results_agg_supp_H0 <- ddply(subset(da_sim_results_agg, support == 'H0'),
                           c('n', 'band'),
                           summarise,
                           freq = length(bf)/nIter)

# If there are no values for this
if(nrow(da_sim_results_agg_supp_H0) == 0){
  da_sim_results_agg_supp_H0 <- data.frame(n = seq(minN, maxN, batchSize),
                                  band = rep('< 1/10', 5),
                                  freq = rep(0, 5))
}


# Upper Histogram
upper_hist <- ggplot(da_sim_results_agg_supp_H1, aes(x = n, y = freq, fill = band)) + 
  geom_bar(stat = "identity", show.legend = FALSE, alpha = 0.5, width = barWidth)  +
  scale_fill_BF() +
  coord_cartesian(ylim = c(0, bar_yAxis), xlim = c(minN - 0.5, maxN + 0.5), expand = FALSE) +
  labs(y = 'Frequency', x = plot_caption) +
  scale_x_continuous(position = 'top') + 
  theme(axis.title.x = element_text(colour = "black", size = 20),
        axis.text.x = element_text(colour = "white"),
        axis.ticks.x = element_line(colour = "white"),
        plot.margin = unit(c(panMar, panMar, panMar, 0), "cm"))

# Create line plot
linePlot <- ggplot(da_sim_results, aes(x = n, y = trans_bf, group = id, colour = band)) + 
  geom_line(alpha = 0.05, show.legend = FALSE) + 
  scale_colour_BF() +
  geom_hline(yintercept = 5) +
  geom_hline(yintercept = -5) +
  scale_y_continuous(breaks = breaksVal,
                     labels = breaksLab) +
  coord_cartesian(xlim = c(minN, maxN), ylim = middle_xlim, expand = FALSE) +
  labs(y = expression(BF[10]), x = NULL) +
  theme(axis.title.x = element_blank(),
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        plot.margin = unit(c(panMar, panMar, panMar, 0), "cm"))

# Create right histogram
right_hist <- ggplot(da_sim_results_agg_undecided, aes(x = trans_bf, fill = band)) +
  coord_flip(ylim = c(0, hist_yAxis), xlim = middle_xlim, expand = FALSE) +
  geom_histogram(alpha = 0.5, show.legend = FALSE) +
  scale_fill_BF(drop = FALSE) +
  labs(y = 'Count', x = NULL) +
  theme(axis.title.y = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        axis.title.x = element_blank(),
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        plot.margin = unit(c(panMar, panMar, panMar, 0), "cm"))

# Create lower histogram
lower_hist <- ggplot(da_sim_results_agg_supp_H0, aes(x = n, y = freq, fill = band)) + 
  scale_y_reverse() +
  scale_fill_BF(drop = F) +
  geom_bar(stat = "identity", show.legend = FALSE, alpha = 0.5, width = barWidth) + 
  labs(y = 'Frequency', x = 'Sample size') +
  coord_cartesian(ylim = c(bar_yAxis, 0), xlim = c(minN -0.5, maxN + 0.5), expand = FALSE) +
  theme(plot.margin = unit(c(panMar, panMar, panMar, 0), "cm"))


# Combine everything into one plot
## Get Grobs
gplot1 <- ggplotGrob(upper_hist)
gplot2 <- ggplotGrob(linePlot)
gplot3 <- ggplotGrob(right_hist) 
gplot4 <- ggplotGrob(lower_hist)

## Get gtables
gt_gplot1  <- gtable_frame(gplot1,  width = unit(12, "null"))
gt_gplot2  <- gtable_frame(gplot2,  width = unit(12, "null"))
gt_gplot3  <- gtable_frame(gplot3,  width = unit(3, "null"))
gt_gplot4  <- gtable_frame(gplot4,  width = unit(12, "null"))
gt_gBlank2 <- gtable_frame(gBlank2, width = unit(3, "null"))

## Combine components
gt_upper   <- gtable_frame(gtable_cbind(gt_gplot1, gt_gBlank2)) 
gt_middle  <- gtable_frame(gtable_cbind(gt_gplot2, gt_gplot3))
gt_lower   <- gtable_frame(gtable_cbind(gt_gplot4, gt_gBlank2))

## Combine into 1 plot
gtable_combined3 <- gtable_frame(gtable_rbind(gt_upper, gt_middle, gt_lower))
```

```{r exp2_designAnalysis_table3}
table12 <- as.data.frame(table(df_H2_agg$band)/nIter)
names(table12) <- c('Support', 'Percent')
#kable(table12, format = 'html', caption = "Table 12: Results of simulation for effect size similar to m-shaped room (within vs. across)")
```

```{r plot_in_1_figure, eval = FALSE}
# Create legend plot
legendPlot <- ggplot(da_sim_results_agg_undecided, aes(x = trans_bf, fill = band)) +
  geom_histogram(alpha = 0.5) +
  scale_fill_BF(drop = FALSE) +
  theme(plot.margin = unit(c(0, 0, 0, 0), "cm")) +
  guides(fill = guide_legend(title = expression(BF[10])))
legend <- cowplot::get_legend(legendPlot)

# Combine plots with legend
all3_plots <- arrangeGrob(gtable_combined1, gtable_combined2, gtable_combined3, legend, ncol = 2)

# Save as image
save_plot('Design_analysis.png', all3_plots,
          base_height = 19/cm(1),
          base_width = 19/cm(1),
          base_aspect_ratio = 1)
```


### Summary
```{r exp2_designAnalysis_summary}
table13 <- data.frame(v1 = c('d = 0.00', 'd = 0.44', 'd = 0.78'),
                      v2 = c(median(df_H0_agg$n), median(df_H1_agg$n), median(df_H2_agg$n)),
                      v3 = c(sum(table10[7:8, 2]), sum(table11[1:2, 2]), sum(table12[1:2, 2])),
                      v  = c(sum(table10[1:2, 2]), sum(table11[7:8, 2]), sum(table12[7:8, 2])))
names(table13) <- c('Effect size', 'Median sample size', 'Evidence rate', 'Misleading evidence rate')
kable(table13, format = 'html', caption = 'Table 13: Summary of design analysis simulation.')
```

In sum with exception  of the third simulation, the evidence rate is not very high being around 60%. In contrast, the rate of misleading evidence was low throughout (<= 0.03). Since, the actual maximal sample size was increased after this simulation, I decided go ahead despite the relatively low evidence rate considering that I might not need a sample size of 36 for the M-room, so that I could use the remaining resources for the O-rooms.  


## Planned analysis
The main planned analysis was a paired t-test between within and across room associations for both room types on arcsince transformed accuracy data of the first block. I will used directional t-tests as I expect within room associations to be better than across room associations. I restricted this analysis to data from the first block because of the possibility that the second block would not yield an effect due to interference from the first block. 

As additional analyses we plan to run a Bayesian ANOVA with with factors boundary (within vs across), question (Which object came before? vs. Which object came after?) and block (Block 1 and Block 2). The aim of this analysis is to find whether this is the case. In case, we find no modulation, we will also include data . Furthermore, we will run another ANOVA with boundary and room type as factors to investigate whether the boundary effect (if existing) is stronger comparing both room times. Since, this involves are between subject comparison that is not directional, we might not have sample size that is big enough. Therefore, we do not make this part of our stopping rule. 

## Sample
```{r exp2_demographics}
# Load data
exp2_demographics <- read.table("~/boundaryVR/data/Exp2/exp2_demographics.csv", header = TRUE, sep = ',')

# Exclude returned (only approved)
exp2_demographics <- exp2_demographics[exp2_demographics$status == 'APPROVED', ]

# Exclude no codes 
exp2_demographics <- exp2_demographics[exp2_demographics$entered_code != 'NOCODE', ]

# Exclude Manual Completion
exp2_demographics <- exp2_demographics[exp2_demographics$entered_code != 'Manual Completion', ]

# Create strings
str1      <- mean_SD_str2(na.omit(exp2_demographics$age), 1)
sex_table <- table(droplevels.factor(exp2_demographics$Sex))
```

In total, 16 participants  (`r sex_table[1]` female and `r sex_table[2]` male)  recruited through prolific completed this version of the experiment. Their age was `r str1` years. 

## Results
```{r exp2_loadData}
exp2_path      <- "~/boundaryVR/data/Exp2"
folder         <- '/memoryTask/'
allFiles       <- list.files(paste0(exp2_path, folder))
allFiles_paths <- paste0(exp2_path, folder, allFiles)
n              <- length(allFiles_paths)

# Loop
for(i in 1:n){
  ############
  # Loading daya
  tempDF <- read.csv(allFiles_paths[i], header = TRUE, na.strings = '')
  
  # Recode key presses
  response      <- rep(NA, nrow(tempDF))
  response[tempDF$key_press == 49] <- 1
  response[tempDF$key_press == 50] <- 2
  response[tempDF$key_press == 51] <- 3
  tempDF$response                  <- response
  
  # Convert RT to numeric  
  tempDF$rt <- suppressWarnings(as.numeric(as.character(tempDF$rt)))
  
  ############
  # Temporal order memory 1
  temporalOrder1 <- subset(tempDF, test_part == 'temporalOrder1')
  
  # Calculate accuracy 
  accuracy <- rep(NA, nrow(temporalOrder1))
  accuracy[temporalOrder1$response == temporalOrder1$corr_resp] <- 1
  accuracy[temporalOrder1$response != temporalOrder1$corr_resp] <- 0
  temporalOrder1$accuracy <- accuracy
  
  # Create variable that desribe whether target, foil1, foil2 was choosen
  choice <- rep('Target', nrow(temporalOrder1))
  choice[temporalOrder1$response == temporalOrder1$foil1Pos] <- 'Foil 1'
  choice[temporalOrder1$response == temporalOrder1$foil2Pos] <- 'Foil 2'
  temporalOrder1$choice <- choice
  
  # Direction of question
  if(temporalOrder1$questionOrder[1] == 0){
    temporalOrder1$questionType = 'before'
  } else {
    temporalOrder1$questionType = 'after'
  }
  
   ############
  # Temporal order memory 2
  temporalOrder2 <- subset(tempDF, test_part == 'temporalOrder2')

  # Calcalate accuracy 
  accuracy <- rep(NA, nrow(temporalOrder2))
  accuracy[temporalOrder2$response == temporalOrder2$corr_resp] <- 1
  accuracy[temporalOrder2$response != temporalOrder2$corr_resp] <- 0
  temporalOrder2$accuracy <- accuracy
  
  # Create variable that desribe whether target, foil1, foil2 was choosen
  choice <- rep('Target', nrow(temporalOrder2))
  choice[temporalOrder2$response == temporalOrder2$foil1Pos] <- 'Foil 1'
  choice[temporalOrder2$response == temporalOrder2$foil2Pos] <- 'Foil 2'
  temporalOrder2$choice <- choice
  
  # Direction of question
  if(temporalOrder2$questionOrder[1] == 0){
    temporalOrder2$questionType = 'after'
  } else {
    temporalOrder2$questionType = 'before'
  }
  
  # Create or bind to data.frame
  if(i == 1){
    df_order_exp2    <- rbind(temporalOrder1, temporalOrder2)
    df_order_exp2$id <- i
  } else {
    temporalOrder1$id <- i
    temporalOrder2$id <- i
    df_order_exp2      <- rbind(df_order_exp2, rbind(temporalOrder1, temporalOrder2))
  }
}

# Convert to id factor
df_order_exp2$id       <- as.factor(df_order_exp2$id)
df_order_exp2$stimulus <- as.character(df_order_exp2$stimulus)

# Get trial number etc. 
exp2_trials     <- ddply(df_order_exp2, c('worker_id','counterbalance_condition', 'questionType', 'context'), summarise, n = length(worker_id))
exp2_trials_agg <- ddply(exp2_trials, c('counterbalance_condition', 'questionType', 'context'), summarise, n = mean(n))
```

```{r exp2_agg1}
# Aggregate
agg_order_exp2 <- ddply(df_order_exp2, c('worker_id', 
                                         'roomType', 
                                         'context', 
                                         'test_part', 
                                         'questionType', 
                                         'counterbalance_condition'), 
                        summarise, 
                        n = length(accuracy),
                        acc = mean(accuracy), 
                        rt = mean(rt))

# Transform values
agg_order_exp2$trans_acc <- arcsine_transform(agg_order_exp2$acc)

# Subset to first block
agg_order_exp2_sub1 <- subset(agg_order_exp2, test_part  == 'temporalOrder1')
```

```{r exp2_plot1}
plt1 <- ggplot(agg_order_exp2_sub1, aes(x = context, y = acc)) + 
  geom_line(aes(group = worker_id)) +
  geom_point() +
  geom_boxplot(width = 0.5, alpha = 0.5) + 
  geom_hline(yintercept = 1/3) +
  stat_summary(geom = "point", fun = "mean", col = 'black', size = 3, shape = 24, fill = 'red')+
  geom_segment(aes(x = 0.7, xend = 0.7, y= 0.1, yend= 1/3),colour = 'black',
               arrow = arrow(length = unit(0.30,"cm"), type = "closed"), show.legend = FALSE) +
  annotate('text', x = 0.7, y = 0.1 - 0.03, label = 'Chance') +
  labs(title = 'Temporal order', y = "3AFC accruacy", x = 'Boundary')


plt2 <- ggplot(agg_order_exp2_sub1, aes(x = context, y = rt)) + 
  geom_line(aes(group = worker_id)) +
  geom_point() +
  geom_boxplot(width = 0.5, alpha = 0.5) + 
  stat_summary(geom = "point", fun = "mean", col = 'black', size = 3, shape = 24, fill = 'red')+
  labs(title = 'Reaction time', y = "RT in msec", x = 'Boundary')


 plot_grid(plt1, plt2)
```


```{r exp2_test1}
# Boundary effect
## Memory accuracy
## Main test on which the stopping rule depended
test1 <- ttestBF(agg_order_exp2_sub1$trans_acc[agg_order_exp2_sub1$context == 'within'],
                 agg_order_exp2_sub1$trans_acc[agg_order_exp2_sub1$context == 'across'],
                 paired = TRUE,
                 nullInterval = c(-Inf, 0))

test1 <- reportBF(1/test1[2])

## RT
test2 <- ttestBF(agg_order_exp2_sub1$rt[agg_order_exp2_sub1$context == 'within'],
                 agg_order_exp2_sub1$rt[agg_order_exp2_sub1$context == 'across'],
                 paired = TRUE,
                 nullInterval = c(-Inf, 0))

test2 <- reportBF(1/test2[1])
```

I stopped data collection at 16, after I reached the stopping criterion. The results was evidence that there is not boundary effect for the first block for accuracy, $BF_{01}$ = `r test1`. There was also no evidence that there is boundary effect for RT, $BF_{01}$ = `r test2`.


```{r exp2_test2}
# Aggregate
agg2_order_exp2 <- ddply(df_order_exp2, c('worker_id', 
                                         'roomType', 
                                         'context', 
                                         'counterbalance_condition'), 
                        summarise, 
                        n = length(accuracy),
                        acc = mean(accuracy), 
                        rt = mean(rt))

# Transform values
agg2_order_exp2$trans_acc <- arcsine_transform(agg2_order_exp2$acc)

# Boundary effect
## Memory accuracy
test1 <- ttestBF(agg2_order_exp2$trans_acc[agg2_order_exp2$context == 'within'],
                 agg2_order_exp2$trans_acc[agg2_order_exp2$context == 'across'],
                 paired = TRUE,
                 nullInterval = c(-Inf, 0))

test1 <- reportBF(1/test1[2])

## RT
test2 <- ttestBF(agg2_order_exp2$rt[agg2_order_exp2$context == 'within'],
                 agg2_order_exp2$rt[agg2_order_exp2$context == 'across'],
                 paired = TRUE,
                 nullInterval = c(-Inf, 0))

test2 <- reportBF(1/test2[1])
```

This result also held true when collapsing across question type. In this case, there was also evidence against an boundary effect for accuracy, $BF_{01}$ = `r test1`, and for RT, $BF_{01}$ = `r test2`.


```{r exp2_test3}
agg_order_exp2$worker_id     <- as.factor(agg_order_exp2$worker_id)
agg_order_exp2$context       <- as.factor(agg_order_exp2$context)
agg_order_exp2$questionType  <- as.factor(agg_order_exp2$questionType)
agg_order_exp2$test_part     <- as.factor(agg_order_exp2$test_part)

anova1 <- anovaBF(trans_acc ~ context*questionType*test_part + worker_id, 
                  whichRandom = 'worker_id', 
                  data = agg_order_exp2,
                  whichModels = 'top')

test1 <- reportBF(1/anova1[5])
```

The planned ANOVA with context, question type and block did not produce strong evidence for the presence or absence of an effect apart for the main effect of question type, $BF_{10}$ = `r test1`. 

```{r exp2_test4}
#Aggregate
agg_order_exp2_overall <- ddply(df_order_exp2, ('worker_id'), summarise, acc  = mean(accuracy))
agg_order_exp2_overall$trans_acc <- arcsine_transform(agg_order_exp2_overall$acc)

# Overall test
test1 <- ttestBF(agg_order_exp2_overall$trans_acc - arcsine_transform(1/3), nullInterval = c(-Inf, 0))
test1 <- reportBF(test1[2])
```

Overall, memory performance was low but above chance $BF_{10}$ = `r test1`. 

## Discussion
Unfortunately, I again failed to provide evidence for a boundary effect for O-rooms. Possible reasons for this repeated failure might be a) that memory performance might be above chance but still too low and b) rooms might look to similar to each other. 

# Experiment 3
## Changes to the experiment
```{r exp3_performance_in_Horner2016}
# Just averaging Aidan's table
aidan_overall <- round(mean(c(aidansData1$accuracy, aidansData2$accuracy)), 2)

# Our overall memory performance
our_overall <- round(mean(agg_order_exp2_overall$acc), 2)
```

Surprisingly, I was not able to report evidence in favour of a boundary effect for O-rooms. However directly comparing, I found that memory performance in Horner et al (2016) was slightly higher with `r aidan_overall` across experiments and than overall memory performance was in Experiment 2, which was `r our_overall`. The main aim for Experiment 3 was there to further improve overall memory performance. 

To do this, I decided to implement three major changes a) memory encoding in Experiment 3 was intentional, b) there were two study-test cycles so that only 44 objects at a time were encoded in a block and c) rooms were made even more distinct. 

In the Experiment 1 & 2, only five different wall colours and five different floor textures were used, which means a room was only unique due to the combination fo the five colours and textures. To increase the distinctiveness in Experiment 3, each floor featured a unique texture that was selected to stand out (e.g. brightly coloured tiles, noticeable carpet patterns etc.). 

## Sample
```{r exp3_demographics}
# Load data
exp3_demographics <- read.table("~/boundaryVR/data/Exp3/exp3_demographics.csv", header = TRUE, sep = ',')

# Exclude returned (only approved)
exp3_demographics <- exp3_demographics[exp3_demographics$status == 'APPROVED', ]

# Create strings
str1      <- mean_SD_str2(na.omit(exp3_demographics$age), 1)
sex_table <- table(droplevels.factor(exp3_demographics$Sex))
```

In total,  49 participants  (`r sex_table[1]` female and `r sex_table[2]` male) recruited through prolific completed this version of the experiment. Their age was `r str1` years. 

## Results
<!-- Could add analysis for video data here -->

```{r exp3_loadData}
# Path
exp3_path <- "~/boundaryVR/data/Exp3/batch1/"

# Get all files
folder1         <- '/memoryTask1/'
folder2         <- '/memoryTask2/'
allFiles1       <- list.files(paste0(exp3_path, folder1))
allFiles2       <- list.files(paste0(exp3_path, folder2))
allFiles1_paths <- paste0(exp3_path, folder1, allFiles1)
allFiles2_paths <- paste0(exp3_path, folder2, allFiles2)
n1              <- length(allFiles1_paths)
n2              <- length(allFiles2_paths)

# Half 1 
for(i in 1:n1){
  ############
  # Loading data
  tempDF <- read.csv(allFiles1_paths[i], header = TRUE, na.strings = '')
  
  # Recode key presses
  response      <- rep(NA, nrow(tempDF))
  response[tempDF$key_press == 49] <- 1
  response[tempDF$key_press == 50] <- 2
  response[tempDF$key_press == 51] <- 3
  tempDF$response                  <- response
  
  # Convert RT to numeric  
  tempDF$rt <- suppressWarnings(as.numeric(as.character(tempDF$rt)))
  
  ############
  # Temporal order memory 1
  temporalOrder1 <- subset(tempDF, test_part == 'temporalOrder')
  
  # Calculate accuracy 
  accuracy <- rep(NA, nrow(temporalOrder1))
  accuracy[temporalOrder1$response == temporalOrder1$corr_resp] <- 1
  accuracy[temporalOrder1$response != temporalOrder1$corr_resp] <- 0
  temporalOrder1$accuracy <- accuracy
  
  # Create variable that describe whether target, foil1, foil2 was chosen
  choice <- rep('Target', nrow(temporalOrder1))
  choice[temporalOrder1$response == temporalOrder1$foil1Pos] <- 'Foil 1'
  choice[temporalOrder1$response == temporalOrder1$foil2Pos] <- 'Foil 2'
  temporalOrder1$choice <- choice
  
  # Create or bind to data.frame
  if(i == 1){
    df_order_exp3_h1    <- temporalOrder1
    df_order_exp3_h1$id <- i
  } else {
    temporalOrder1$id <- i
    df_order_exp3_h1      <- rbind(df_order_exp3_h1, temporalOrder1)
  }
}

# Half 2
for(i in 1:n2){
  ############
  # Loading data
  tempDF <- read.csv(allFiles2_paths[i], header = TRUE, na.strings = '')
  
  # Recode key presses
  response      <- rep(NA, nrow(tempDF))
  response[tempDF$key_press == 49] <- 1
  response[tempDF$key_press == 50] <- 2
  response[tempDF$key_press == 51] <- 3
  tempDF$response                  <- response
  
  # Convert RT to numeric  
  tempDF$rt <- suppressWarnings(as.numeric(as.character(tempDF$rt)))
  
  ############
  # Temporal order memory 1
  temporalOrder1 <- subset(tempDF, test_part == 'temporalOrder')
  
  # Calculate accuracy 
  accuracy <- rep(NA, nrow(temporalOrder1))
  accuracy[temporalOrder1$response == temporalOrder1$corr_resp] <- 1
  accuracy[temporalOrder1$response != temporalOrder1$corr_resp] <- 0
  temporalOrder1$accuracy <- accuracy
  
  # Create variable that describe whether target, foil1, foil2 was chosen
  choice <- rep('Target', nrow(temporalOrder1))
  choice[temporalOrder1$response == temporalOrder1$foil1Pos] <- 'Foil 1'
  choice[temporalOrder1$response == temporalOrder1$foil2Pos] <- 'Foil 2'
  temporalOrder1$choice <- choice
  
  
  # Create or bind to data.frame
  if(i == 1){
    df_order_exp3_h2    <- temporalOrder1
    df_order_exp3_h2$id <- i
  } else {
    temporalOrder1$id <- i
    df_order_exp3_h2    <- rbind(df_order_exp3_h2, temporalOrder1)
  }
}


df_order_exp3         <- rbind(df_order_exp3_h1, df_order_exp3_h2)
df_order_exp3$half    <- factor(df_order_exp3$half, levels = c(0, 1), labels = c('h1', 'h2'))
df_order_exp3$context <- factor(df_order_exp3$context, levels = c('across', 'within'), labels = c('across', 'within'))

# Get trial number etc. 
exp3_trials     <- ddply(df_order_exp3, c('worker_id','counterbalance_condition', 'context'), summarise, n = length(worker_id))
exp3_trials_agg <- ddply(exp3_trials, c('counterbalance_condition', 'context'), summarise, n = mean(n))
```

```{r exp3_memory_outlier}
# Outlier detection
outlier_data <- ddply(df_order_exp3, c('worker_id'), summarise, accuracy = mean(accuracy), rt = mean(rt))
outlier_data$trans_acc         <- arcsine_transform(outlier_data$accuracy)
outlier_data$trans_acc_outlier <- mad_outlier(outlier_data$trans_acc, 2)
outlier_data$rt_outlier        <- mad_outlier(outlier_data$rt, 3)

# Outlier removal
df_order_exp3 <- df_order_exp3[!(df_order_exp3$worker_id %in% c(15177, outlier_data[outlier_data$trans_acc_outlier == 1, 'worker_id'])), ] 
# 15177 Didn't do whole task

excluded <- round(mean(outlier_data$trans_acc_outlier)*100, 1)

# Final sample size
n <- length(unique(df_order_exp3$worker_id))
```

One participant was excluded by because they did not completed the task. Furthermore, average transformed (overall) accuracy was treated as an outlier if it was above/below two median absolute deviations from the median. This led to the exclusion of `r excluded` % of the data. Leaving final sample of `r n` participants. 

```{r exp3_plot1}
## Aggregate data
agg_order_exp3 <- ddply(df_order_exp3, c('worker_id', 'subjCond','context'), summarise, accuracy = mean(accuracy), rt = mean(rt))

# Transform accuracy
agg_order_exp3$trans_acc <- arcsine_transform(agg_order_exp3$accuracy)


# Plot
plt1 <- ggplot(agg_order_exp3, aes(x = context, y = accuracy)) + 
  geom_line(aes(group = worker_id)) +
  geom_point() +
  geom_boxplot(width = 0.5, alpha = 0.5) + 
  geom_hline(yintercept = 1/3) +
  stat_summary(geom = "point", fun = "mean", col = 'black', size = 3, shape = 24, fill = 'red')+
  geom_segment(aes(x = 0.7, xend = 0.7, y= 0.1, yend= 1/3),colour = 'black',
               arrow = arrow(length = unit(0.30,"cm"), type = "closed"), show.legend = FALSE) +
  annotate('text', x = 0.7, y = 0.1 - 0.03, label = 'Chance') +
  labs(title = 'Temporal order', y = "3AFC accruacy", x = 'Boundary')


plt2 <- ggplot(agg_order_exp3, aes(x = context, y = rt)) + 
  geom_line(aes(group = worker_id)) +
  geom_point() +
  geom_boxplot(width = 0.5, alpha = 0.5) + 
  stat_summary(geom = "point", fun = "mean", col = 'black', size = 3, shape = 24, fill = 'red')+
  labs(title = 'Reaction time', y = "RT in msec", x = 'Boundary')

 plot_grid(plt1, plt2)
```


```{r exp3_test1}
# Boundary effect
## Memory accuracy
test1 <- ttestBF(agg_order_exp3$trans_acc[agg_order_exp3$context == 'within'],
                 agg_order_exp3$trans_acc[agg_order_exp3$context == 'across'],
                 paired = TRUE,
                 nullInterval = c(-Inf, 0))

test1 <- reportBF(1/test1[2])

## RT
test2 <- ttestBF(agg_order_exp3$rt[agg_order_exp3$context == 'within'],
                 agg_order_exp3$rt[agg_order_exp3$context == 'across'],
                 paired = TRUE,
                 nullInterval = c(-Inf, 0))

test2 <- reportBF(1/test2[1])
```

The analysis revealed again no boundary effect for O-rooms both for accuracy $BF_{01}$ = `r test1` as well as for RT $BF_{01}$ = `r test2`. 

```{r exp3_test2}
#Aggregate
agg_order_exp3_overall <- ddply(df_order_exp3, ('worker_id'), summarise, acc  = mean(accuracy))
agg_order_exp3_overall$trans_acc <- arcsine_transform(agg_order_exp3_overall$acc)

# Overall test
test1 <- ttestBF(agg_order_exp3_overall$trans_acc - arcsine_transform(1/3), nullInterval = c(-Inf, 0))
test1 <- reportBF(test1[2])

# Strings
str1 <- mean_SD_str(mean(agg_order_exp3_overall$acc), sd(agg_order_exp3_overall$trans_acc))
```

This is despite the fact that average overall memory accuracy did improve as expected with `r str1`, which was clearly above chance $BF_{10}$ = `r test1`

## Discussion
Even with better performance, there was still no evidence for a boundary effect of O-rooms. Due to time constraints, I have not been able to make further changes to the experimental design to replicate the basic effect. 

# General discussion
In three experiments, I have been unable to provide evidence in favour of boundary effect for O-rooms and only once for M-rooms. I will therefore spent the remaining part of this chapter deliberating what could be the reasons for this. 

## Potential reasons for the null effect
While I have made the rooms more distinct and the memory task itself easier successfully improving overall memory performance, two major differences between my experiment and the experiments reported in Horner et al. (2016) remain. First, in Horner et al. (2016) navigation was active, while in the series of experiment reported here participants merely watched a video. Second, the position of the tables and the floorplans in Horner et al. (2016) varied. In this experiment, rooms apart from the fact that there were M and O-rooms were the same. The room variation allowed Horner and colleagues to created a closed circle of rooms, while here the rooms all laid on a linear track. 

Another difference was that I used an online sample. Even though it is conceivable that this influenced our results, it an unlikely explanation as memory performance was above chance. For instances, even in in Experiment 1 where performance was worse participant could remember on which table an object was presented. 

The layout of was the rooms were in series of experiments here because it allowed to create a larger number of them and dynamically create an environment. Further options that have not been tried out that would make the room more distinct would be adding decoration to the rooms (e.g. wall paints or symbols) or even adding music or sounds for each room. 

<!-- Add general remarks on robustness of this finding  -->
