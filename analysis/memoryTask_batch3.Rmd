---
title: "Analysis of memory task"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = TRUE, message = FALSE, warning = FALSE)
library(rjson)
library(ggplot2)
library(MRColour)
library(cowplot)
library(knitr)
library(plyr)
library(reshape2)
theme_set(theme_grey()) # Important to retain the ggplot theme
library(ez)
library(lmerTest)
```

```{r loadData, echo = FALSE}
# Load all data
prefix         <- 'U:/Projects/boundaryVR/analysis/batch3/memoryTask/'
allFiles       <- list.files(paste(prefix, sep = ''))
allFiles_paths <- paste(prefix, allFiles, sep = '')
n              <- length(allFiles_paths)

for(i in 1:n){
  tempDF <- read.csv(allFiles_paths[i], header = TRUE, na.strings = '')
  # To be able to visualise
  #tempDF$stimulus         <- NULL 
  tempDF$success          <- NULL
  tempDF$trial_type       <- NULL
  tempDF$internal_node_id <- NULL
  
  # Temporal order memory
  temporalOrder    <- subset(tempDF, test_part == 'temporalOrder')
  temporalOrder$rt <- as.numeric(as.character(temporalOrder$rt))
  # Recode key presses
  response      <- rep(NA, dim(temporalOrder)[1])
  response[temporalOrder$key_press == 49] <- 1
  response[temporalOrder$key_press == 50] <- 2
  response[temporalOrder$key_press == 51] <- 3
  temporalOrder$response                  <- response
  
  # Calcalate accuracy 
  accuracy <- rep(NA, dim(temporalOrder)[1])
  accuracy[temporalOrder$response == temporalOrder$corr_resp] <- 1
  accuracy[temporalOrder$response != temporalOrder$corr_resp] <- 0
  temporalOrder$accuracy <- accuracy
   
  # Room type question
  roomType      <- subset(tempDF, test_part == 'roomType')
  roomType$rt   <- as.numeric(as.character(roomType$rt))
  
  # Recode key presses
  response      <- rep(NA, dim(roomType)[1])
  response[roomType$key_press == 49] <- 1
  response[roomType$key_press == 50] <- 2
  roomType$response                  <- response
  
  # Calculate accuracy
  accuracy <- rep(NA, dim(roomType)[1])
  accuracy[roomType$response == roomType$corr_resp] <- 1
  accuracy[roomType$response != roomType$corr_resp] <- 0
  roomType$accuracy <- accuracy
  
  
  # Table question
  tableNum      <- subset(tempDF, test_part == 'tableNum')
  tableNum$rt   <- as.numeric(as.character(tableNum$rt))
  
  # Recode keypresses
  response      <- rep(NA, dim(tableNum)[1])
  response[tableNum$key_press == 49] <- 3 # for key press 1
  response[tableNum$key_press == 50] <- 2 # for key press 2
  tableNum$response                  <- response
  
  # Calculate accuracy
  accuracy <- rep(NA, dim(tableNum)[1])
  accuracy[tableNum$response == tableNum$corr_resp] <- 1
  accuracy[tableNum$response != tableNum$corr_resp] <- 0
  tableNum$accuracy <- accuracy
  
  # Create or bind to data.frame
  if(i == 1){
    temporalOrder_comb    <- temporalOrder
    temporalOrder_comb$id <- i
    roomType_comb         <- roomType
    roomType_comb$id      <- i
    tableNum_comb         <- tableNum
    tableNum_comb$id      <- i
  } else {
    temporalOrder$id   <- i
    temporalOrder_comb <- rbind(temporalOrder_comb, temporalOrder)
    roomType$id        <- i
    roomType_comb      <- rbind(roomType_comb, roomType)
    tableNum$id        <- i
    tableNum_comb      <- rbind(tableNum_comb, tableNum)
  }
}

# Convert to id factor
temporalOrder_comb$id <- as.factor(temporalOrder_comb$id)
roomType_comb$id      <- as.factor(roomType_comb$id)
tableNum_comb$id      <- as.factor(tableNum_comb$id)
```

# Analyse data
## Temporal order memory
```{r}
# Aggregate data 1
temporalOrder_agg <- ddply(temporalOrder_comb, c('id', 'context'), summarise, 
                           n = length(rt),
                           acc = mean(accuracy), 
                           rt = mean(rt))

# # Aggregate data 1
temporalOrder_comb$context2 <- as.character(temporalOrder_comb$context)
temporalOrder_comb[temporalOrder_comb$context == 'within-no-walls', 'context2'] <- 'within'
temporalOrder_comb[temporalOrder_comb$context == 'within-walls', 'context2'] <- 'within'

temporalOrder_agg2 <- ddply(temporalOrder_comb, c('id', 'context2'), summarise, 
                           n = length(rt),
                           acc = mean(accuracy), 
                           rt = mean(rt))

afcPlot <- ggplot(temporalOrder_agg, aes(x = context, y = acc)) + 
  geom_boxplot(alpha = 0.5,outlier.shape = NA) + 
  geom_jitter(width = 0.1) +
  geom_hline(yintercept = 1/3) +
  annotate('text', x = 2, y = 0.31, label = 'Chance') +
  labs(y = '3AFC accuracy', x = "Room type", title = 'Temporal Order')


rtPlot <- ggplot(temporalOrder_agg, aes(x = context, y = rt)) + 
  geom_boxplot(alpha = 0.5, outlier.shape = NA) + 
  geom_jitter(width = 0.5) +
  labs(y = 'RT (msec)', x = "Room type", title = '')

plot_grid(afcPlot, rtPlot)
```

As can be seen above, some participants seems to significantly perform below chance. To show this, I simulated a null distribution (see below). In an ANOVA, there were no difference between the conditions:
```{r}
ezANOVA(temporalOrder_agg, dv = acc, wid = id, within = context)
```

### Temporal memory: across vs. within
```{r}
ggplot(temporalOrder_agg2, aes(x = context2, y = acc)) + 
  geom_boxplot(alpha = 0.5,outlier.shape = NA) + 
  geom_jitter(width = 0.1) +
  geom_hline(yintercept = 1/3) +
  annotate('text', x = 2, y = 0.31, label = 'Chance') +
  labs(y = '3AFC accuracy', x = "Room type", title = 'Temporal Order')

t.test(temporalOrder_agg2[temporalOrder_agg2$context2 == 'across', 4], 
       temporalOrder_agg2[temporalOrder_agg2$context2 == 'within', 4])
```


## Room and table question
```{r}
#Aggregate data
roomType_comb_agg <- ddply(roomType_comb, c('id'), summarise, acc = mean(accuracy), rt = mean(rt))
tableNum_comb_agg <- ddply(tableNum_comb, c('id'), summarise, acc = mean(accuracy), rt = mean(rt))

roomTable_agg <- data.frame(id = rep(1:n, 2),
                            Type = rep(c('Room', 'Table'), each = n),
                            acc = c(roomType_comb_agg$acc, tableNum_comb_agg$acc))

ggplot(roomTable_agg, aes(x = Type, y = acc)) + 
  geom_boxplot(alpha = 0.5,outlier.shape = NA) + 
  geom_jitter(width = 0.1) +
  geom_hline(yintercept = 0.5) +
  annotate('text', x = 1.5, y = 0.48, label = 'Chance') +
  labs(y = 'Accuracy', x = "Memory type", title = 'Memory for room type and table')

```

While performance for the room task was not above chance

```{r}
t.test(roomType_comb_agg$acc -0.5)
```

the performance for the table question was:

```{r}
t.test(tableNum_comb_agg$acc - 0.5)
```

# Predicting trial-to-trial accruacy and influence of foil distance
For this section, I fished around to see what the relationship between context and foil distance might be and whether the effect of context differs as a function of the foil distance. 

```{r}
# Create data.frame to analyse trial-to-trial accuracy 
temporalOrder_comb_foilDist <- ddply(temporalOrder_comb,
                                     c('id', 'trial_index', 'context'),
                                     summarise,
                                     minDist = min(abs(dist1), abs(dist2)),
                                     maxDist = max(abs(dist1), abs(dist2)),
                                     meanDist = mean(abs(dist1), abs(dist2)),
                                     dist1 = dist1,
                                     dist2 = dist2,
                                     accuracy = accuracy)

# Predictin accuracy based on context
m_context <- glmer(accuracy ~ context + (1| id ), 
                   family = binomial, 
                   data = temporalOrder_comb_foilDist)
summary(m_context)
```

This actually shows tha the contrast between across and within-walls is close to be significant. 

```{r}

m_foil1 <- glmer(accuracy ~ minDist + maxDist + meanDist + (1 | id ), 
                 family = binomial, 
                 data = temporalOrder_comb_foilDist)
summary(m_foil1)
```

No absolute aggregate meassures across both foils predict accuracy. 

```{r}
m_foil2 <- glmer(accuracy ~ dist1 + dist2 + (1 | id ), 
                 family = binomial, 
                 data = temporalOrder_comb_foilDist)
summary(m_foil2)
```

If both raw distances are entered, then the distance of foil2 is close to be significant. This foil is like the target after the probe. The other foil doesn't seem to have an influence. 

```{r}
m_context2 <- glmer(accuracy ~ context*dist2 + (1| id ), 
                    family = binomial, 
                    data = temporalOrder_comb_foilDist)
summary(m_context2)
```

If we controll for the difference of foil 2, then the effect of within-walls get bigger and both the contrast between across and within-walls and the effect of the distance of foil 2 are close to be significant. 

## Binary distance
```{r}
binDist2 <- rep('close', dim(temporalOrder_comb_foilDist)[1])
binDist2[temporalOrder_comb_foilDist$dist2 >= median(temporalOrder_comb_foilDist$dist2)] <- 'far'
temporalOrder_comb_foilDist$binDist2 <- binDist2

m_context3 <- glmer(accuracy ~ context*binDist2 + (1| id ), 
                    family = binomial, 
                    data = temporalOrder_comb_foilDist)
summary(m_context3)
```

## Effect of condition
```{r}
temporalOrder_comb$condition <- as.factor(temporalOrder_comb$condition)
m_context3 <- glmer(accuracy ~ context*condition + (1| id ), 
                   family = binomial, 
                   data = temporalOrder_comb)
summary(m_context3)
```

# Conclusion
Obviously, this all has to be taken with the caution that a) post-hoc fishing and b) low N. So I think we should run another batch. 