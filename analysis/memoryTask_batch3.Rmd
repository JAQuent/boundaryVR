---
title: "Analysis of memory task"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, eval = TRUE, message = FALSE, warning = FALSE)
library(rjson)
library(ggplot2)
library(MRColour)
library(cowplot)
library(knitr)
library(plyr)
library(reshape2)
theme_set(theme_grey()) # Important to retain the ggplot theme
library(ez)
library(assortedRFunctions)
library(lmerTest)
```

```{r loadData, echo = FALSE}
# Load all data
prefix         <- '~/GitHub/boundaryVR/analysis/batch3/memoryTask/'
allFiles       <- list.files(paste(prefix, sep = ''))
allFiles_paths <- paste(prefix, allFiles, sep = '')
n              <- length(allFiles_paths)

for(i in 1:n){
  tempDF <- read.csv(allFiles_paths[i], header = TRUE, na.strings = '')
  # To be able to visualise
  #tempDF$stimulus         <- NULL 
  tempDF$success          <- NULL
  tempDF$trial_type       <- NULL
  tempDF$internal_node_id <- NULL
  
  # Temporal order memory
  temporalOrder    <- subset(tempDF, test_part == 'temporalOrder')
  temporalOrder$rt <- as.numeric(as.character(temporalOrder$rt))
  # Recode key presses
  response      <- rep(NA, dim(temporalOrder)[1])
  response[temporalOrder$key_press == 49] <- 1
  response[temporalOrder$key_press == 50] <- 2
  response[temporalOrder$key_press == 51] <- 3
  temporalOrder$response                  <- response
  
  # Calcalate accuracy 
  accuracy <- rep(NA, dim(temporalOrder)[1])
  accuracy[temporalOrder$response == temporalOrder$corr_resp] <- 1
  accuracy[temporalOrder$response != temporalOrder$corr_resp] <- 0
  temporalOrder$accuracy <- accuracy
   
  # Room type question
  roomType      <- subset(tempDF, test_part == 'roomType')
  roomType$rt   <- as.numeric(as.character(roomType$rt))
  
  # Recode key presses
  response      <- rep(NA, dim(roomType)[1])
  response[roomType$key_press == 49] <- 1
  response[roomType$key_press == 50] <- 2
  roomType$response                  <- response
  
  # Calculate accuracy
  accuracy <- rep(NA, dim(roomType)[1])
  accuracy[roomType$response == roomType$corr_resp] <- 1
  accuracy[roomType$response != roomType$corr_resp] <- 0
  roomType$accuracy <- accuracy
  
  
  # Table question
  tableNum      <- subset(tempDF, test_part == 'tableNum')
  tableNum$rt   <- as.numeric(as.character(tableNum$rt))
  
  # Recode keypresses
  response      <- rep(NA, dim(tableNum)[1])
  response[tableNum$key_press == 49] <- 3 # for key press 1
  response[tableNum$key_press == 50] <- 2 # for key press 2
  tableNum$response                  <- response
  
  # Calculate accuracy
  accuracy <- rep(NA, dim(tableNum)[1])
  accuracy[tableNum$response == tableNum$corr_resp] <- 1
  accuracy[tableNum$response != tableNum$corr_resp] <- 0
  tableNum$accuracy <- accuracy
  
  # Create or bind to data.frame
  if(i == 1){
    temporalOrder_comb    <- temporalOrder
    temporalOrder_comb$id <- i
    roomType_comb         <- roomType
    roomType_comb$id      <- i
    tableNum_comb         <- tableNum
    tableNum_comb$id      <- i
  } else {
    temporalOrder$id   <- i
    temporalOrder_comb <- rbind(temporalOrder_comb, temporalOrder)
    roomType$id        <- i
    roomType_comb      <- rbind(roomType_comb, roomType)
    tableNum$id        <- i
    tableNum_comb      <- rbind(tableNum_comb, tableNum)
  }
}

# Convert to id factor
temporalOrder_comb$id <- as.factor(temporalOrder_comb$id)
roomType_comb$id      <- as.factor(roomType_comb$id)
tableNum_comb$id      <- as.factor(tableNum_comb$id)
```

# Analyse data
## Temporal order memory
```{r}
# Aggregate data 1
temporalOrder_agg <- ddply(temporalOrder_comb, c('id', 'context'), summarise, 
                           n = length(rt),
                           acc = mean(accuracy), 
                           rt = mean(rt))

# # Aggregate data 1
temporalOrder_comb$context2 <- as.character(temporalOrder_comb$context)
temporalOrder_comb[temporalOrder_comb$context == 'within-no-walls', 'context2'] <- 'within'
temporalOrder_comb[temporalOrder_comb$context == 'within-walls', 'context2'] <- 'within'

temporalOrder_agg2 <- ddply(temporalOrder_comb, c('id', 'context2'), summarise, 
                           n = length(rt),
                           acc = mean(accuracy), 
                           rt = mean(rt))

afcPlot <- ggplot(temporalOrder_agg, aes(x = context, y = acc)) + 
  geom_boxplot(alpha = 0.5,outlier.shape = NA) + 
  geom_jitter(width = 0.1) +
  geom_hline(yintercept = 1/3) +
  annotate('text', x = 2, y = 0.31, label = 'Chance') +
  labs(y = '3AFC accuracy', x = "Room type", title = 'Temporal Order')


rtPlot <- ggplot(temporalOrder_agg, aes(x = context, y = rt)) + 
  geom_boxplot(alpha = 0.5, outlier.shape = NA) + 
  geom_jitter(width = 0.5) +
  labs(y = 'RT (msec)', x = "Room type", title = '')

plot_grid(afcPlot, rtPlot)
```

As you can see above, most participants now perform above chance. Below, you see the ANOVA compring the different conditions.

```{r}
result1 <- ezANOVA(temporalOrder_agg, dv = acc, wid = id, within = context)
p1 <- result1$`Sphericity Corrections`$`p[GG]`

result2 <-  pairwise.t.test(temporalOrder_agg$acc, temporalOrder_agg$context, p.adj = "none")
```

Interestingly, there was a main effect of context, p `r pValue(p1)`. In **uncorrected** pairwise t-tests, performance in the within-wall condition was better than across rooms, p `r pValue(result2$p.value[2, 1])`, and better than in the within-no-walls condition, p `r pValue(result2$p.value[2, 2])`. However, performance in the within-no-wall condition was not better than in the across condition, p `r pValue(result2$p.value[1, 1])`. The average values can be found here:

```{r}
kable(ddply(temporalOrder_agg, c('context'), summarise, accuracy = mean(acc), SD = sd(acc)))
```

### Temporal memory: across vs. within
```{r}
ggplot(temporalOrder_agg2, aes(x = context2, y = acc)) + 
  geom_boxplot(alpha = 0.5,outlier.shape = NA) + 
  geom_jitter(width = 0.1) +
  geom_hline(yintercept = 1/3) +
  annotate('text', x = 2, y = 0.31, label = 'Chance') +
  labs(y = '3AFC accuracy', x = "Room type", title = 'Temporal Order')

result3 <- t.test(temporalOrder_agg2[temporalOrder_agg2$context2 == 'across', 4], 
                  temporalOrder_agg2[temporalOrder_agg2$context2 == 'within', 4])
```

When I colllasp across both within-room conditions, the difference between across and within rooms is significantly different, p `r pValue(result3$p.value)`.

## Room and table question
```{r}
#Aggregate data
roomType_comb_agg <- ddply(roomType_comb, c('id'), summarise, acc = mean(accuracy), rt = mean(rt))
tableNum_comb_agg <- ddply(tableNum_comb, c('id'), summarise, acc = mean(accuracy), rt = mean(rt))

roomTable_agg <- data.frame(id = rep(1:n, 2),
                            Type = rep(c('Room', 'Table'), each = n),
                            acc = c(roomType_comb_agg$acc, tableNum_comb_agg$acc))

ggplot(roomTable_agg, aes(x = Type, y = acc)) + 
  geom_boxplot(alpha = 0.5,outlier.shape = NA) + 
  geom_jitter(width = 0.1) +
  geom_hline(yintercept = 0.5) +
  annotate('text', x = 1.5, y = 0.48, label = 'Chance') +
  labs(y = 'Accuracy', x = "Memory type", title = 'Memory for room type and table')


result4 <- t.test(roomType_comb_agg$acc -0.5)
result5 <- t.test(tableNum_comb_agg$acc - 0.5)
```

As in Batch 2, participants did not perform above chance for the room type question, p `r pValue(result4$p.value)` but they did for the table question, p `r pValue(result5$p.value)`.

# Predicting trial-to-trial accruacy and influence of foil distance
For this section, I fished around to see what the relationship between context and foil distance might be and whether the effect of context differs as a function of the foil distance. 

```{r}
# Create data.frame to analyse trial-to-trial accuracy 
temporalOrder_comb_foilDist <- ddply(temporalOrder_comb,
                                     c('id', 'trial_index', 'context'),
                                     summarise,
                                     minDist = min(abs(dist1), abs(dist2)),
                                     maxDist = max(abs(dist1), abs(dist2)),
                                     meanDist = mean(abs(dist1), abs(dist2)),
                                     dist1 = dist1,
                                     dist2 = dist2,
                                     accuracy = accuracy)

# Predictin accuracy based on context
m_context <- glmer(accuracy ~ context + (1| id ), 
                   family = binomial, 
                   data = temporalOrder_comb_foilDist)

table1 <- createResultTable(m_context)
kable(table1)
```

In a logistic regrression model (see above) with context as fixed effect and a random intercept for each participant, the contrast between across and within-no-wall was not significant, p `r pValue(table1$P[2])`, while the contrast between across and within-walls was, p `r pValue(table1$P[3])`.

```{r}

m_foil1 <- glmer(accuracy ~ minDist + maxDist + meanDist + (1 | id ), 
                 family = binomial, 
                 data = temporalOrder_comb_foilDist)

table2 <- createResultTable(m_foil1)
kable(table2)
```

In another step, I tried to predict accuracy by including fixed effects for the absolute minimum, maximum and mean distance values of foil 1 (before cue/probe) and foil 2 (after cue/probe). In other words, for each trial I for instance used the minimum of both absolute distances. However as can you can see above, none significantly predicts accuracy. 

```{r}
m_foil2 <- glmer(accuracy ~ dist1 + dist2 + (1 | id ), 
                 family = binomial, 
                 data = temporalOrder_comb_foilDist)

table3 <- createResultTable(m_foil2)
kable(table3)
```

When I use the raw distance values of foil 1 and foil 2, there again were no significant effects even though the distance of foil 2 to the cue/probe was relatively small, p `r pValue(table3$P[3])`.

```{r}
m_context2 <- glmer(accuracy ~ context*dist2 + (1| id ), 
                    family = binomial, 
                    data = temporalOrder_comb_foilDist)

table4 <- createResultTable(m_context2)
kable(table4)
```

In a next step, I included context and dist2 as predictors in the logistic regression model and allowed an interaction between both fixed effects. As you can see none of the interactions are significant but, a) there is again a significant contrast between across and within-walls, p `r pValue(table4$P[3])`. Most interestingly, there is also trend for the contrast between across and within-no-walls, p `r pValue(table4$P[2])`.  

## Binary distance
```{r}
binDist2 <- rep('close', dim(temporalOrder_comb_foilDist)[1])
binDist2[temporalOrder_comb_foilDist$dist2 >= median(temporalOrder_comb_foilDist$dist2)] <- 'far'
temporalOrder_comb_foilDist$binDist2 <- binDist2

m_context3 <- glmer(accuracy ~ context*binDist2 + (1| id ), 
                    family = binomial, 
                    data = temporalOrder_comb_foilDist)

table5 <- createResultTable(m_context3)
kable(table5)
```

If I use a binary measure of foil distance instead of a continuous one, then the effects don't chance a lot actually. 

## Effect of condition
```{r}
temporalOrder_comb$condition <- as.factor(temporalOrder_comb$condition)
m_context4 <- glmer(accuracy ~ context*condition + (1| id ), 
                   family = binomial, 
                   data = temporalOrder_comb)

table6 <- createResultTable(m_context4)
kable(table6)
```

In the last step, I included condition as fixed effect. After replacing the problematic participants it's a good sign that there are no significant interactions left between any context contrast and conditions. 

# Conclusion
We have robust and strong effect in the within-wall condition and only when we controll for distance between foil 2 to the cue/probe, there is a trend for the contrast between across and within-no-walls. 